<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>‰∫îÂ≠êÊ£ã - ËàáÂ∞èÂÖãÂ∞çÂºà</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Á∂ìÂÖ∏‰∫îÂ≠êÊ£ãÈÄ£Áè†ÈÅäÊà≤ÔºåÈ¶ñÂÖàÂ∞á‰∫îÂÄãÊ£ãÂ≠êÈÄ£Êàê‰∏ÄÁ∑öËÄÖÁç≤Âãù„ÄÇËàáAIÂ∞çÊâãÂ∞èÂÖãÂ∞çÂºàÔºå‰∏≠Êñá‰ªãÈù¢ÔºåÁßªÂãïË®≠ÂÇôÂÑ™Âåñ„ÄÇ">
    <meta name="keywords" content="‰∫îÂ≠êÊ£ã, ÈÄ£Áè†, ‰∫îÂ≠êÊ£ãÈÅäÊà≤, AI‰∫îÂ≠êÊ£ã, ‰∏≠Êñá‰∫îÂ≠êÊ£ã, Á≠ñÁï•ÈÅäÊà≤, Â∞èÂÖã, ÁßªÂãïÈÅäÊà≤, Á∂≤È†ÅÈÅäÊà≤">
    <meta name="author" content="Mini Board Games">
    <meta name="theme-color" content="#059669">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://farnghwai.github.io/mini-board-games/gomoku-game-chinese.html">
    <meta property="og:title" content="‰∫îÂ≠êÊ£ã - ËàáÂ∞èÂÖãÂ∞çÂºà">
    <meta property="og:description" content="Á∂ìÂÖ∏‰∫îÂ≠êÊ£ãÈÄ£Áè†ÈÅäÊà≤ÔºåÈ¶ñÂÖàÂ∞á‰∫îÂÄãÊ£ãÂ≠êÈÄ£Êàê‰∏ÄÁ∑öËÄÖÁç≤Âãù„ÄÇËàáAIÂ∞çÊâãÂ∞èÂÖãÂ∞çÂºàÔºå‰∏≠Êñá‰ªãÈù¢ÔºåÁßªÂãïË®≠ÂÇôÂÑ™Âåñ„ÄÇ">
    <meta property="og:locale" content="zh_TW">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary">
    <meta property="twitter:url" content="https://farnghwai.github.io/mini-board-games/gomoku-game-chinese.html">
    <meta property="twitter:title" content="‰∫îÂ≠êÊ£ã - ËàáÂ∞èÂÖãÂ∞çÂºà">
    <meta property="twitter:description" content="Á∂ìÂÖ∏‰∫îÂ≠êÊ£ãÈÄ£Áè†ÈÅäÊà≤ÔºåÈ¶ñÂÖàÂ∞á‰∫îÂÄãÊ£ãÂ≠êÈÄ£Êàê‰∏ÄÁ∑öËÄÖÁç≤Âãù„ÄÇËàáAIÂ∞çÊâãÂ∞èÂÖãÂ∞çÂºàÔºå‰∏≠Êñá‰ªãÈù¢ÔºåÁßªÂãïË®≠ÂÇôÂÑ™Âåñ„ÄÇ">
    <link rel="stylesheet" href="shared-styles.css">
    <style>
        :root {
            /* Game-specific color overrides */
            --primary-gradient: linear-gradient(135deg, #10b981 0%, #059669 100%);
            --shadow-button: 0 4px 15px rgba(16, 185, 129, 0.4);

            /* Gomoku-specific board variables */
            --board-bg: #b45309;
            --board-inner: #d97706;
            --board-lines: #8b4513;

            /* Gomoku stone variables */
            --stone-black: #000;
            --stone-white: #fff;
            --stone-white-border: #333;
            --stone-black-border-hc: #000000;
            --stone-white-border-hc: #333333;
        }

        .game-title {
            font-size: clamp(1.25rem, 5vw, 1.75rem);
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            text-align: center;
        }

        #score-area {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: clamp(1.5rem, 5vw, 2rem);
            margin-bottom: 0.75rem;
        }

        .score-item {
            font-size: clamp(0.875rem, 3.5vw, 1.125rem);
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .score-stone {
            width: clamp(1.25rem, 4vw, 1.5rem);
            height: clamp(1.25rem, 4vw, 1.5rem);
            border-radius: 50%;
            display: inline-block;
        }

        .black-stone {
            background: var(--stone-black);
        }

        .white-stone {
            background: var(--stone-white);
            border: 1px solid var(--stone-white-border);
        }


        /* #boardContainer styles now in shared-styles.css */

        #game-board {
            background: var(--board-inner);
            padding: 0.125rem;
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 0.3125rem;
            touch-action: none;
        }

        .board-row {
            display: flex;
            width: 100%;
            height: calc(100% / 13);
        }

        .board-cell {
            width: calc(100% / 13);
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            min-width: max(18px, 5cqw);
            min-height: max(18px, 5cqw);
        }

        @container (max-width: 280px) {
            .board-cell {
                min-width: 16px;
                min-height: 16px;
            }
        }

        .grid-lines {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .grid-line {
            stroke: var(--board-lines);
            stroke-width: 1;
        }

        .placed-stone {
            width: max(80%, 16px);
            height: max(80%, 16px);
            border-radius: 50%;
            z-index: 10;
            position: relative;
            transition: transform 0.2s;
        }

        @container (min-width: 350px) {
            .placed-stone {
                width: max(85%, 20px);
                height: max(85%, 20px);
            }
        }

        .placed-stone.black {
            background: radial-gradient(circle at 30% 30%, #4a4a4a, #000000);
            box-shadow: 0.125rem 0.125rem 0.25rem rgba(0,0,0,0.5);
        }

        .placed-stone.white {
            background: radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0);
            border: 1px solid #ccc;
            box-shadow: 0.125rem 0.125rem 0.25rem rgba(0,0,0,0.3);
        }

        .placed-stone.last-move {
            box-shadow: 0 0 0 2px #ef4444, 0.125rem 0.125rem 0.25rem rgba(0,0,0,0.5);
        }

        .placed-stone.winning {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 2px #10b981; }
            50% { box-shadow: 0 0 0 4px #10b981; }
        }

        .hover-preview {
            width: max(75%, 14px);
            height: max(75%, 14px);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 5;
            position: relative;
        }

        @container (min-width: 350px) {
            .hover-preview {
                width: max(80%, 18px);
                height: max(80%, 18px);
            }
        }

        .star-point {
            position: absolute;
            width: max(0.375rem, 1.5cqw);
            height: max(0.375rem, 1.5cqw);
            background: #000;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }

        @container (max-width: 250px) {
            .star-point {
                width: 0.25rem;
                height: 0.25rem;
            }
        }


        #controls {
            min-height: 3rem;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0.25rem 0;
            gap: 0.5rem;
        }

        #controls .control-button {
            display: none;
        }

        #controls .control-button.show {
            display: flex;
        }

        .control-button.inline {
            padding: 0.5rem 1.5rem;
            font-size: 0.875rem;
            min-height: 2rem;
            border-radius: 1rem;
        }





        /* Gomoku-specific responsive adjustments */
        @media (max-width: 400px) {
            #score-area {
                gap: 1rem;
            }

            .score-item {
                font-size: 0.875rem;
            }
        }

        /* #boardContainer responsive styles now in shared-styles.css */

        @media (prefers-contrast: high) {
            .placed-stone.black {
                border: 2px solid #000000;
            }

            .placed-stone.white {
                border: 2px solid #333333;
            }
        }

        @media (max-height: 540px) {
            :root {
                --game-content-width: calc(13 * 16px + 0.25rem + 2 * clamp(0.5rem, 2vw, 0.75rem));
            }

            #board-container {
                min-width: calc(13 * 16px + 0.25rem + 2 * clamp(0.5rem, 2vw, 0.75rem));
                min-height: calc(13 * 16px + 0.25rem + 2 * clamp(0.5rem, 2vw, 0.75rem));
            }
        }

        /* Gomoku-specific compact mode adjustments */
        @media (max-height: 650px) {
            .control-button {
                padding: 0.5rem 1rem;
                font-size: 0.875rem;
                min-height: 2.5rem;
            }

            #controls {
                min-height: 2.5rem;
                padding: 0.125rem 0;
            }

            #score-area {
                gap: 1rem;
                margin-bottom: 0.25rem;
            }

            .score-item {
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Welcome Screen -->
        <div id="welcome-screen">
            <h1 class="welcome-title">Ê≠°Ëøé‰æÜÂà∞‰∫îÂ≠êÊ£ã‰∏ñÁïå</h1>
            <p class="welcome-message">ÊÇ®Â•ΩÔºÅÊàëÊòØÊ£ãÂèãÂ∞èÂÖãÔºÅ<br>ËÆìÊàëÂÄë‰∏ÄËµ∑‰∫´Âèó‰∏ãÊ£ãÁöÑÊ®ÇË∂£ÂêßÔºÅ</p>
            <button class="start-button" onclick="startFirstGame()">ÈñãÂßã‰∏ãÊ£ã</button>
        </div>

        <!-- Game Screen -->
        <div id="game-screen">
            <div class="game-header">
                <h1 class="game-title">‰∫îÂ≠êÊ£ã</h1>
                <div id="score-area">
                    <div class="score-item">
                        <span>ÊÇ®Ôºö</span>
                        <span id="player-score">0</span>
                        <span class="score-stone black-stone"></span>
                    </div>
                    <div class="score-item">
                        <span>Â∞èÂÖãÔºö</span>
                        <span id="npc-score">0</span>
                        <span class="score-stone white-stone"></span>
                    </div>
                </div>

                <div id="message-area">
                    <div id="ai-message">Ê∫ñÂÇôÈñãÂßã...</div>
                </div>
            </div>

            <div class="game-board-area">
                <div id="board-container">
                    <div id="game-board"></div>
                </div>
            </div>

            <div class="game-footer">
                <div id="controls">
                    <button class="control-button inline restart hidden" onclick="startNewGame()">ÂÜç‰æÜ‰∏ÄÂ±Ä</button>
                    <button class="control-button inline new-session hidden" onclick="newSession()">Êñ∞Â±Ä</button>
                </div>

                <div id="session-info">
                    Á¨¨ <span id="session-games">0</span> Â±Ä ‚Ä¢ ‰ªäÊó•Â∑≤Áé© <span id="total-games">0</span> Â±Ä
                </div>
            </div>
        </div>
        </div>
    </div>

    <script>
        // Game state
        let board = [];
        let currentPlayer = 'player';
        let gameActive = false;
        let isProcessing = false;
        let score = { player: 0, npc: 0 };
        let sessionGames = 0;
        let totalGamesToday = 0;
        let lastMove = null;
        let winningLine = null;
        let hoveredPosition = null;

        // NPC settings
        let npcDifficulty = 'easy';
        let localResponsesUsed = [];

        // Local response system - Chinese language
        const localResponses = {
            greetings: [
                "‰æÜ‰∏ãÊ£ãÂêßÔºÅÊÇ®Âü∑ÈªëÂ≠êÂÖà‰∏ãÔºÅ‚ö´",
                "ÈñãÂßãÂõâÔºÅÈªûÊìäÊ£ãÁõ§‰ªªÊÑè‰ΩçÁΩÆËêΩÂ≠êÔºÅ",
                "ÊàëÂÄë‰æÜ‰∏ã‰∫îÂ≠êÊ£ãÔºÅÊÇ®ÂÖàË´ãÔºÅ",
                "Ê∫ñÂÇôÂ•Ω‰∫ÜÂóéÔºüËºïËß∏Ê£ãÁõ§ÈñãÂßãÔºÅ"
            ],
            playerMoves: {
                good: ["Â•ΩÊ£ãÔºÅ", "‰∏çÈåØÂñîÔºÅ", "ÊúâÊÑèÊÄùÔºÅ", "Âé≤ÂÆ≥ÔºÅ", "ÊÇ®ÁúüËÅ∞ÊòéÔºÅ"],
                normal: ["Ëº™Âà∞Êàë‰∫Ü", "Êàë‰æÜÊÉ≥ÊÉ≥", "ÂóØ...", "ËÆìÊàëÁúãÁúã", "Êúâ‰∫ÜÔºÅ"],
                winning: ["ÂìéÂëÄÔºåÊÇ®Ë¶ÅË¥è‰∫ÜÔºÅ", "ÊàëÂæóÂ∞èÂøÉ‰∫ÜÔºÅ", "Âç±Èö™ÂïäÔºÅ", "ÊÇ®ÁöÑÊ£ãË∑ØÂæàÂé≤ÂÆ≥ÔºÅ"]
            },
            npcMoves: {
                normal: ["Êàë‰∏ãÈÄôË£°ÔºÅ", "Ë©¶Ë©¶ÈÄôÊ≠•", "ÈÄôË£°Â¶Ç‰ΩïÔºü", "ÊàëËµ∞‰∏ÄÊ≠•", "Ëº™Âà∞ÊàëÂõâÔºÅ"],
                blocking: ["Êìã‰ΩèÔºÅüòä", "‰∏çËÉΩËÆìÊÇ®ÂæóÊâãÔºÅ", "ÊàëÁúãÂà∞‰∫ÜÔºÅ", "ÊîîÊà™ÔºÅ", "ÂìàÂìàÔºåÊìã‰Ωè‰∫ÜÔºÅ"],
                winning: ["ÈÄôÊ≠•‰∏çÈåØ", "ÊàëÂñúÊ≠°ÈÄôÂÄã‰ΩçÁΩÆ", "ÂóØÔºåÈÄôË£°ÔºÅ", "ËÆìÊàëË©¶Ë©¶..."]
            },
            playerWin: [
                "ÊÅ≠ÂñúÊÇ®Ë¥è‰∫ÜÔºÅüéâ",
                "ÊÇ®ÁúüÂé≤ÂÆ≥ÔºÅ‰Ω©Êúç‰Ω©ÊúçÔºÅ",
                "ÊÇ®Ë¥èÂï¶ÔºÅÂÜç‰æÜ‰∏ÄÂ±ÄÂóéÔºü",
                "È´òÊâãÔºÅÊÇ®Ë¥è‰∫ÜÔºÅ",
                "ÊºÇ‰∫ÆÔºÅÈÄôÂ±ÄÊÇ®Ë¥è‰∫ÜÔºÅ"
            ],
            npcWin: [
                "ÊàëÂÉ•ÂÄñË¥è‰∫ÜÔºÅÂÜç‰æÜ‰∏ÄÂ±ÄÂóéÔºü",
                "ÈÄôÂ±ÄÊàëË¥è‰∫ÜÔºåÂÜçË©¶Ë©¶ÁúãÔºü",
                "ÊâøËÆì‰∫ÜÔºÅË¶Å‰∏çË¶ÅÂÜç‰æÜÔºü",
                "ÈÅãÊ∞£‰∏çÈåØÔºåÊàëË¥è‰∫ÜÔºÅ"
            ],
            draw: [
                "Âπ≥Â±ÄÔºÅÊàëÂÄëÂØ¶ÂäõÁõ∏Áï∂ÔºÅ",
                "ÂíåÊ£ã‰∫ÜÔºÅÁ≤æÂΩ©ÁöÑÂ∞çÂ±ÄÔºÅ",
                "‰∏çÂàÜÂãùË≤†ÔºÅÂÜç‰æÜ‰∏ÄÂ±ÄÔºü"
            ],
            encouragement: [
                "ÊÇ®‰∏ãÂæóÂæàÂ•ΩÔºÅ",
                "ÊÖ¢ÊÖ¢‰æÜÔºå‰∏çËëóÊÄ•ÔºÅ",
                "Â•ΩÊ£ãÂ±ÄÔºÅ",
                "ÁúüÊúâË∂£ÔºÅ",
                "ÊÇ®Ë∂ä‰æÜË∂äÂé≤ÂÆ≥‰∫ÜÔºÅ"
            ]
        };

        // Initialize board
        function initBoard() {
            board = Array(13).fill(null).map(() => Array(13).fill(null));
            lastMove = null;
            winningLine = null;
            currentPlayer = 'player';
            renderBoard();
        }

        // Render board
        function renderBoard() {
            const boardElement = document.getElementById('game-board');
            boardElement.innerHTML = '';

            for (let row = 0; row < 13; row++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'board-row';

                for (let col = 0; col < 13; col++) {
                    const cellDiv = document.createElement('div');
                    cellDiv.className = 'board-cell';
                    cellDiv.dataset.row = row;
                    cellDiv.dataset.col = col;

                    // Add grid lines
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.classList.add('grid-lines');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', '100%');

                    // Horizontal line
                    if (col < 12) {
                        const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        hLine.setAttribute('x1', '50%');
                        hLine.setAttribute('y1', '50%');
                        hLine.setAttribute('x2', '100%');
                        hLine.setAttribute('y2', '50%');
                        hLine.classList.add('grid-line');
                        svg.appendChild(hLine);
                    }
                    if (col > 0) {
                        const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        hLine.setAttribute('x1', '0');
                        hLine.setAttribute('y1', '50%');
                        hLine.setAttribute('x2', '50%');
                        hLine.setAttribute('y2', '50%');
                        hLine.classList.add('grid-line');
                        svg.appendChild(hLine);
                    }

                    // Vertical line
                    if (row < 12) {
                        const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        vLine.setAttribute('x1', '50%');
                        vLine.setAttribute('y1', '50%');
                        vLine.setAttribute('x2', '50%');
                        vLine.setAttribute('y2', '100%');
                        vLine.classList.add('grid-line');
                        svg.appendChild(vLine);
                    }
                    if (row > 0) {
                        const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        vLine.setAttribute('x1', '50%');
                        vLine.setAttribute('y1', '0');
                        vLine.setAttribute('x2', '50%');
                        vLine.setAttribute('y2', '50%');
                        vLine.classList.add('grid-line');
                        svg.appendChild(vLine);
                    }

                    cellDiv.appendChild(svg);

                    // Add star points
                    if ((row === 3 && col === 3) ||
                        (row === 3 && col === 9) ||
                        (row === 9 && col === 3) ||
                        (row === 9 && col === 9) ||
                        (row === 6 && col === 6)) {
                        const starPoint = document.createElement('div');
                        starPoint.className = 'star-point';
                        cellDiv.appendChild(starPoint);
                    }

                    // Add stone if present
                    if (board[row][col]) {
                        const stone = document.createElement('div');
                        stone.className = 'placed-stone';
                        stone.classList.add(board[row][col] === 'player' ? 'black' : 'white');

                        // Highlight last move
                        if (lastMove && lastMove.row === row && lastMove.col === col) {
                            stone.classList.add('last-move');
                        }

                        // Highlight winning stones
                        if (winningLine && winningLine.some(([r, c]) => r === row && c === col)) {
                            stone.classList.add('winning');
                        }

                        cellDiv.appendChild(stone);
                    }

                    // Add click handler
                    cellDiv.onclick = () => handleCellClick(row, col);
                    cellDiv.onmouseenter = () => handleCellHover(row, col, true);
                    cellDiv.onmouseleave = () => handleCellHover(row, col, false);

                    rowDiv.appendChild(cellDiv);
                }

                boardElement.appendChild(rowDiv);
            }
        }

        // Handle cell click
        function handleCellClick(row, col) {
            if (!gameActive || currentPlayer !== 'player' || isProcessing) return;
            if (board[row][col] !== null) return;

            isProcessing = true;

            // Place player stone
            board[row][col] = 'player';
            lastMove = { row, col };
            renderBoard();

            // Check for player win
            const playerWin = checkWinner(row, col, 'player');
            if (playerWin) {
                winningLine = playerWin;
                renderBoard();
                score.player++;
                totalGamesToday++;
                localStorage.setItem('gomokuGamesToday', totalGamesToday.toString());
                updateScore();
                updateSessionInfo();
                showMessage(getLocalResponse('playerWin'));
                gameActive = false;
                isProcessing = false;
                showEndButtons();
                return;
            }

            // Check for draw
            if (checkDraw()) {
                showMessage(getLocalResponse('draw'));
                gameActive = false;
                isProcessing = false;
                showEndButtons();
                return;
            }

            // Show processing message
            showMessage(getLocalResponse('playerMoves', 'normal'));

            // NPC turn
            currentPlayer = 'npc';
            setTimeout(() => {
                makeNPCMove();
            }, 800);
        }

        // Handle cell hover
        function handleCellHover(row, col, isHovering) {
            if (!gameActive || currentPlayer !== 'player' || board[row][col] !== null) {
                return;
            }

            const cell = document.querySelector(`.board-cell[data-row="${row}"][data-col="${col}"]`);
            const existingPreview = cell.querySelector('.hover-preview');

            if (isHovering && !existingPreview) {
                const preview = document.createElement('div');
                preview.className = 'hover-preview';
                cell.appendChild(preview);
            } else if (!isHovering && existingPreview) {
                existingPreview.remove();
            }
        }

        // Make NPC move
        function makeNPCMove() {
            const move = calculateNPCMove();
            if (!move) {
                showMessage("Ê≤íÂú∞Êñπ‰∏ã‰∫ÜÔºÅ");
                gameActive = false;
                isProcessing = false;
                showEndButtons();
                return;
            }

            board[move.row][move.col] = 'npc';
            lastMove = { row: move.row, col: move.col };
            renderBoard();

            // Check for NPC win
            const npcWin = checkWinner(move.row, move.col, 'npc');
            if (npcWin) {
                winningLine = npcWin;
                renderBoard();
                score.npc++;
                totalGamesToday++;
                localStorage.setItem('gomokuGamesToday', totalGamesToday.toString());
                updateScore();
                updateSessionInfo();
                showMessage(getLocalResponse('npcWin'));
                gameActive = false;
                isProcessing = false;
                showEndButtons();
                return;
            }

            // Check for draw
            if (checkDraw()) {
                showMessage(getLocalResponse('draw'));
                gameActive = false;
                isProcessing = false;
                showEndButtons();
                return;
            }

            // Continue game
            showMessage(getLocalResponse('npcMoves', 'normal'));
            currentPlayer = 'player';
            isProcessing = false;
        }

        // Calculate NPC move
        function calculateNPCMove() {
            // Check for winning move (4 in a row, need 5th)
            const winMove = findBestMove('npc', 5);
            if (winMove) return winMove;

            // Check for blocking move (opponent has 4)
            const blockMove = findBestMove('player', 5);
            if (blockMove) return blockMove;

            // Check for creating 4 in a row
            const createFour = findBestMove('npc', 4);
            if (createFour) return createFour;

            // Block opponent's 3 in a row
            const blockThree = findBestMove('player', 4);
            if (blockThree) return blockThree;

            // Easy mode: sometimes make random moves
            if (npcDifficulty === 'easy' && Math.random() < 0.3) {
                return getRandomMove();
            }

            // Prefer center area
            return getCenterMove();
        }

        // Find best move for target length
        function findBestMove(player, targetLength) {
            for (let row = 0; row < 13; row++) {
                for (let col = 0; col < 13; col++) {
                    if (board[row][col] === null) {
                        // Test this position
                        board[row][col] = player;
                        const length = checkLineLength(row, col, player);
                        board[row][col] = null;

                        if (length >= targetLength) {
                            return { row, col };
                        }
                    }
                }
            }
            return null;
        }

        // Check line length from position
        function checkLineLength(row, col, player) {
            const directions = [
                [0, 1], [1, 0], [1, 1], [1, -1]  // horizontal, vertical, diagonal
            ];

            let maxLength = 1;

            for (let [dr, dc] of directions) {
                let length = 1;

                // Check forward direction
                for (let i = 1; i < 5; i++) {
                    const r = row + dr * i;
                    const c = col + dc * i;
                    if (r >= 0 && r < 13 && c >= 0 && c < 13 && board[r][c] === player) {
                        length++;
                    } else break;
                }

                // Check backward direction
                for (let i = 1; i < 5; i++) {
                    const r = row - dr * i;
                    const c = col - dc * i;
                    if (r >= 0 && r < 13 && c >= 0 && c < 13 && board[r][c] === player) {
                        length++;
                    } else break;
                }

                maxLength = Math.max(maxLength, length);
            }

            return maxLength;
        }

        // Get random move near existing stones
        function getRandomMove() {
            const availableMoves = [];
            for (let row = 0; row < 13; row++) {
                for (let col = 0; col < 13; col++) {
                    if (board[row][col] === null) {
                        // Prefer moves near existing stones
                        if (hasNeighbor(row, col)) {
                            availableMoves.push({ row, col });
                        }
                    }
                }
            }

            if (availableMoves.length === 0) {
                // If no moves near stones, pick center area
                return getCenterMove();
            }

            return availableMoves[Math.floor(Math.random() * availableMoves.length)];
        }

        // Check if position has neighbor
        function hasNeighbor(row, col) {
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const r = row + dr;
                    const c = col + dc;
                    if (r >= 0 && r < 13 && c >= 0 && c < 13 && board[r][c] !== null) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Get center area move
        function getCenterMove() {
            const center = 6;
            const range = 3;

            for (let d = 0; d <= range; d++) {
                for (let row = center - d; row <= center + d; row++) {
                    for (let col = center - d; col <= center + d; col++) {
                        if (row >= 0 && row < 13 && col >= 0 && col < 13 && board[row][col] === null) {
                            return { row, col };
                        }
                    }
                }
            }

            // Fallback to any empty position
            for (let row = 0; row < 13; row++) {
                for (let col = 0; col < 13; col++) {
                    if (board[row][col] === null) {
                        return { row, col };
                    }
                }
            }

            return null;
        }

        // Check for winner
        function checkWinner(lastRow, lastCol, player) {
            const directions = [
                [0, 1], [1, 0], [1, 1], [1, -1]  // horizontal, vertical, diagonal
            ];

            for (let [dr, dc] of directions) {
                let count = 1;
                const line = [[lastRow, lastCol]];

                // Check forward direction
                for (let i = 1; i < 5; i++) {
                    const r = lastRow + dr * i;
                    const c = lastCol + dc * i;
                    if (r >= 0 && r < 13 && c >= 0 && c < 13 && board[r][c] === player) {
                        count++;
                        line.push([r, c]);
                    } else break;
                }

                // Check backward direction
                for (let i = 1; i < 5; i++) {
                    const r = lastRow - dr * i;
                    const c = lastCol - dc * i;
                    if (r >= 0 && r < 13 && c >= 0 && c < 13 && board[r][c] === player) {
                        count++;
                        line.unshift([r, c]);
                    } else break;
                }

                if (count >= 5) {
                    return line.slice(0, 5);  // Return first 5 stones
                }
            }

            return null;
        }

        // Check for draw
        function checkDraw() {
            for (let row = 0; row < 13; row++) {
                for (let col = 0; col < 13; col++) {
                    if (board[row][col] === null) return false;
                }
            }
            return true;
        }

        // Get local response without repetition
        function getLocalResponse(category, subcategory = null) {
            let responses;
            if (subcategory) {
                responses = localResponses[category][subcategory];
            } else {
                responses = localResponses[category];
            }

            const availableResponses = responses.filter(r => !localResponsesUsed.includes(r));

            if (availableResponses.length === 0) {
                localResponsesUsed = [];
                return responses[Math.floor(Math.random() * responses.length)];
            }

            const selected = availableResponses[Math.floor(Math.random() * availableResponses.length)];
            localResponsesUsed.push(selected);

            if (localResponsesUsed.length > 10) {
                localResponsesUsed.shift();
            }

            return selected;
        }

        // Show message
        function showMessage(message) {
            document.getElementById('ai-message').textContent = message;
        }

        // Update score display
        function updateScore() {
            document.getElementById('player-score').textContent = score.player;
            document.getElementById('npc-score').textContent = score.npc;
        }

        // Update session info
        function updateSessionInfo() {
            document.getElementById('session-games').textContent = sessionGames;
            document.getElementById('total-games').textContent = totalGamesToday;
        }

        // Show appropriate end buttons
        function showEndButtons() {
            const restartButton = document.querySelector('#controls .restart');
            const newSessionButton = document.querySelector('#controls .new-session');

            // Hide both buttons first
            restartButton.classList.remove('show');
            newSessionButton.classList.remove('show');

            if (sessionGames < 5) {
                restartButton.classList.add('show');
            } else {
                newSessionButton.classList.add('show');
                // End session message
                setTimeout(() => {
                    showMessage(
                        `‰ªäÊó•Êà∞Á∏æÔºöÊÇ®Ë¥è‰∫Ü${score.player}Â±ÄÔºåÊàëË¥è‰∫Ü${score.npc}Â±Ä„ÄÇ` +
                        `Ë¨ùË¨ùÈô™Êàë‰∏ãÊ£ãÔºÅÈªûÊìä„ÄåÊñ∞Â±Ä„ÄçÂèØ‰ª•ÂÜçÁé©„ÄÇ`
                    );
                }, 2000);
            }
        }

        // Hide end buttons from game actions
        function hideEndButtons() {
            const restartButton = document.querySelector('#controls .restart');
            const newSessionButton = document.querySelector('#controls .new-session');

            restartButton.classList.remove('show');
            newSessionButton.classList.remove('show');
        }

        // Start first game
        function startFirstGame() {
            document.getElementById('welcome-screen').style.display = 'none';
            document.getElementById('game-screen').classList.add('active');

            // Initialize session
            totalGamesToday = parseInt(localStorage.getItem('gomokuGamesToday') || '0');
            const lastPlayDate = localStorage.getItem('gomokuLastPlayDate');
            const today = new Date().toDateString();

            if (lastPlayDate !== today) {
                totalGamesToday = 0;
                localStorage.setItem('gomokuLastPlayDate', today);
            }

            startNewGame();
        }

        // Start new game
        function startNewGame() {
            hideEndButtons();
            initBoard();
            gameActive = true;
            isProcessing = false;
            sessionGames++;

            // Note: totalGamesToday is now incremented only when games are completed (won)

            updateSessionInfo();

            // Clear any buttons during game (now handled by gameActions)
            hideEndButtons();

            // Show greeting
            showMessage(getLocalResponse('greetings'));

            // Special messages
            if (sessionGames === 1 && totalGamesToday === 1) {
                const hour = new Date().getHours();
                const timeOfDay = hour < 12 ? 'Êó©‰∏ä' : hour < 17 ? '‰∏ãÂçà' : 'Êôö‰∏ä';
                showMessage(`${timeOfDay}Â•ΩÔºÅÊ≠°Ëøé‰æÜÁé©‰∫îÂ≠êÊ£ãÔºÅÊÇ®Âü∑ÈªëÂ≠êÂÖà‰∏ã„ÄÇ`);
            } else if (sessionGames > 3) {
                showMessage("ÊÇ®ÁúüÊúâËÄêÂøÉÔºÅÈÄôÊòØÁ¨¨" + sessionGames + "Â±Ä‰∫ÜÔºåÊÇ®ÂÖà‰∏ãÔºÅ");
            }
        }

        // New session
        function newSession() {
            // Reset session
            sessionGames = 0;
            score = { player: 0, npc: 0 };
            updateScore();

            // Show welcome screen again
            document.getElementById('game-screen').classList.remove('active');
            document.getElementById('welcome-screen').style.display = 'block';

            const welcomeMessage = document.querySelector('.welcome-message');
            welcomeMessage.innerHTML = `Ê≠°ËøéÂõû‰æÜÔºÅ<br>‰ªäÊó•Êà∞Á∏æÂ∑≤ÈáçÁΩÆ<br>Ê∫ñÂÇôÂ•ΩÂÜç‰æÜ‰∏ÄÂ±Ä‰∫ÜÂóéÔºü`;
        }

        // Initialize on load
        window.onload = function() {
            // Check if returning player
            const lastPlayDate = localStorage.getItem('gomokuLastPlayDate');
            if (lastPlayDate) {
                const welcomeMessage = document.querySelector('.welcome-message');
                welcomeMessage.innerHTML = `Ê≠°ËøéÂõû‰æÜÔºÅ<br>Ê∫ñÂÇôÂ•ΩÁπºÁ∫å‰∏ãÊ£ã‰∫ÜÂóéÔºü`;
            }
        };
    </script>
</body>
</html>