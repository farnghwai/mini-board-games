<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åœæ£‹ - èˆ‡å°å…‹å°å¼ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Microsoft YaHei", "å¾®è»Ÿæ­£é»‘é«”", sans-serif;
            background: linear-gradient(135deg, #f5f5dc 0%, #e8ddc0 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            touch-action: manipulation;
        }

        #gameContainer {
            width: 100%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #welcomeScreen {
            text-align: center;
            padding: 30px 20px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .welcomeTitle {
            font-size: 28px;
            color: #4a4a4a;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .welcomeMessage {
            font-size: 20px;
            color: #666;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .startButton {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 15px 40px;
            font-size: 22px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transition: transform 0.2s;
        }

        .startButton:active {
            transform: scale(0.95);
        }

        #gameScreen {
            display: none;
        }

        #messageArea {
            background: white;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #aiMessage {
            font-size: 18px;
            color: #4a4a4a;
            text-align: center;
            line-height: 1.4;
        }

        #boardContainer {
            background: #deb887;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            position: relative;
            transition: background 0.3s ease;
        }
        
        #boardContainer.easy-mode {
            background: linear-gradient(135deg, #d4c5a9 0%, #deb887 100%);
        }
        
        #boardContainer.medium-mode {
            background: #deb887;
        }
        
        #boardContainer.hard-mode {
            background: linear-gradient(135deg, #deb887 0%, #cd9b5e 100%);
        }

        #board {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            background: #f4d03f;
            background-image: 
                repeating-linear-gradient(0deg, #d4a76a 0, #d4a76a 1px, transparent 1px, transparent 100%),
                repeating-linear-gradient(90deg, #d4a76a 0, #d4a76a 1px, transparent 1px, transparent 100%);
            border-radius: 5px;
        }

        .intersection {
            position: absolute;
            width: 7.69%;
            height: 7.69%;
            cursor: pointer;
            z-index: 3;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stone {
            width: 90%;
            height: 90%;
            border-radius: 50%;
            position: relative;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .stone.black {
            background: radial-gradient(circle at 30% 30%, #4a4a4a, #000000);
            box-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .stone.white {
            background: radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0);
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            border: 1px solid #ccc;
        }

        .stone.preview {
            opacity: 0.5;
        }

        .stone.last-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40%;
            height: 40%;
            border-radius: 50%;
            background: rgba(255, 0, 0, 0.6);
        }

        .star-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #2a2a2a;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
        }

        #gameInfo {
            display: flex;
            justify-content: space-around;
            background: white;
            border-radius: 15px;
            padding: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #settingsBar {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            background: white;
            border-radius: 15px;
            padding: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 10px;
        }

        .settingGroup {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .settingLabel {
            font-size: 14px;
            color: #666;
        }

        .toggleButton {
            background: #f0f0f0;
            border: none;
            border-radius: 20px;
            padding: 6px 12px;
            font-size: 14px;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toggleButton.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .difficultySelector {
            display: flex;
            gap: 5px;
            background: #f8f8f8;
            padding: 3px;
            border-radius: 18px;
        }

        .difficultyButton {
            background: transparent;
            border: none;
            border-radius: 12px;
            padding: 6px 12px;
            font-size: 14px;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
        }

        .difficultyButton:hover {
            background: rgba(0,0,0,0.05);
        }

        .difficultyButton.active {
            background: linear-gradient(135deg, #ffd89b 0%, #ffa751 100%);
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(255, 167, 81, 0.3);
        }

        .difficultyButton:active {
            transform: scale(0.95);
        }

        #board.no-grid {
            background-image: none;
            background: #f4d03f;
        }

        #board.no-grid .gridLine {
            display: block;
        }

        #board:not(.no-grid) .gridLine {
            display: none;
        }

        .gridLine {
            position: absolute;
            background: #d4a76a;
            pointer-events: none;
            z-index: 1;
            opacity: 0.5;
        }

        .gridLine.horizontal {
            width: 100%;
            height: 1px;
        }

        .gridLine.vertical {
            width: 1px;
            height: 100%;
        }

        .infoItem {
            text-align: center;
        }

        .infoLabel {
            font-size: 14px;
            color: #888;
            margin-bottom: 5px;
        }

        .infoValue {
            font-size: 20px;
            font-weight: bold;
            color: #4a4a4a;
        }

        #controls {
            display: flex;
            gap: 10px;
        }

        .controlButton {
            flex: 1;
            background: white;
            border: 2px solid #ddd;
            border-radius: 15px;
            padding: 12px;
            font-size: 18px;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
        }

        .controlButton:active {
            background: #f0f0f0;
            transform: scale(0.95);
        }

        .controlButton:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .controlButton.pass {
            background: linear-gradient(135deg, #ffd89b 0%, #ffa751 100%);
            border: none;
            color: white;
            font-weight: bold;
        }

        .controlButton.resign {
            background: linear-gradient(135deg, #ff9b9b 0%, #ff5151 100%);
            border: none;
            color: white;
            font-weight: bold;
        }

        #endGameModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            padding: 20px;
        }

        .modalContent {
            background: white;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modalTitle {
            font-size: 28px;
            color: #4a4a4a;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .modalScore {
            font-size: 22px;
            color: #666;
            margin-bottom: 15px;
        }

        .modalMessage {
            font-size: 18px;
            color: #888;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        .scoreDetails {
            background: #f8f8f8;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: left;
        }

        .scoreDetail {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            font-size: 16px;
        }

        .scoreDetail:last-child {
            border-bottom: none;
            font-weight: bold;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 2px solid #ccc;
        }

        .scoreDetail.black {
            color: #000;
        }

        .scoreDetail.white {
            color: #666;
        }

        .detailLabel {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .detailValue {
            font-weight: 500;
        }

        .expandButton {
            background: #f0f0f0;
            border: none;
            border-radius: 10px;
            padding: 10px 20px;
            font-size: 16px;
            color: #666;
            cursor: pointer;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            width: 100%;
        }

        .expandButton:active {
            background: #e0e0e0;
        }

        .expandButton::after {
            content: 'â–¼';
            font-size: 12px;
            transition: transform 0.3s;
        }

        .expandButton.expanded::after {
            transform: rotate(180deg);
        }

        .explanationSection {
            display: none;
            background: #fffbf0;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: left;
            border: 2px solid #f0e0c0;
        }

        .explanationSection.show {
            display: block;
        }

        .explanationTitle {
            font-size: 20px;
            color: #4a4a4a;
            margin-bottom: 15px;
            font-weight: bold;
            text-align: center;
        }

        .explanationContent {
            font-size: 16px;
            color: #666;
            line-height: 1.8;
        }

        .explanationContent p {
            margin-bottom: 12px;
        }

        .explanationContent strong {
            color: #4a4a4a;
            font-weight: 600;
        }

        .territoryOverlay {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            opacity: 0.4;
            z-index: 2;
            animation: fadeIn 0.5s ease-in;
        }

        .territoryOverlay.black-territory {
            background: radial-gradient(circle, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.5) 100%);
            box-shadow: 0 0 3px rgba(0,0,0,0.3);
        }

        .territoryOverlay.white-territory {
            background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.6) 100%);
            border: 1px solid rgba(200,200,200,0.8);
            box-shadow: 0 0 3px rgba(255,255,255,0.5);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 0.4; transform: scale(1); }
        }

        .modalButtons {
            display: flex;
            gap: 15px;
        }

        .modalButton {
            flex: 1;
            padding: 12px 20px;
            border-radius: 15px;
            border: none;
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .modalButton.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
        }

        .modalButton.secondary {
            background: #f0f0f0;
            color: #666;
        }

        .modalButton:active {
            transform: scale(0.95);
        }

        @media (max-width: 380px) {
            .welcomeTitle { font-size: 24px; }
            .welcomeMessage { font-size: 18px; }
            .startButton { font-size: 20px; }
            #aiMessage { font-size: 16px; }
            .infoValue { font-size: 18px; }
            .controlButton { font-size: 16px; }
            .settingLabel { font-size: 12px; }
            .toggleButton { padding: 5px 10px; font-size: 13px; }
            .difficultyButton { padding: 5px 8px; font-size: 12px; }
            .difficultySelector { gap: 3px; padding: 2px; }
            .difficultyHint { font-size: 10px; }
            #settingsBar { flex-direction: column; gap: 8px; }
            .settingGroup { justify-content: center; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="welcomeScreen">
            <h1 class="welcomeTitle">æ­¡è¿ä¾†åˆ°åœæ£‹ä¸–ç•Œ</h1>
            <p class="welcomeMessage">æ‚¨å¥½ï¼æˆ‘æ˜¯æ£‹å‹å°å…‹ï¼<br>è®“æˆ‘å€‘ä¸€èµ·äº«å—ä¸‹æ£‹çš„æ¨‚è¶£å§ï¼</p>
            <button class="startButton" onclick="startGame()">é–‹å§‹ä¸‹æ£‹</button>
        </div>

        <div id="gameScreen">
            <div id="messageArea">
                <div id="aiMessage">æ‚¨åŸ·é»‘å­ï¼Œè«‹å…ˆä¸‹ï¼è§¸ç¢°ä»»ä½•äº¤å‰é»è½å­ã€‚</div>
            </div>

            <div id="settingsBar">
                <div class="settingGroup">
                    <span class="settingLabel">æ ¼ç·šï¼š</span>
                    <button class="toggleButton active" id="gridToggle" onclick="toggleGrid()">é–‹å•Ÿ</button>
                </div>
                <div class="settingGroup">
                    <span class="settingLabel">é›£åº¦ï¼š</span>
                    <div class="difficultyWrapper">
                        <div class="difficultySelector">
                            <button class="difficultyButton active" onclick="changeDifficulty('easy')">ç°¡å–®</button>
                            <button class="difficultyButton" onclick="changeDifficulty('medium')">ä¸­ç­‰</button>
                            <button class="difficultyButton" onclick="changeDifficulty('hard')">å›°é›£</button>
                        </div>
                        <div class="difficultyHint" id="difficultyHint" style="font-size: 11px; color: #4CAF50; text-align: center; margin-top: 4px;">å’Œå¹³å»ºè¨­</div>
                    </div>
                </div>
            </div>

            <div id="boardContainer">
                <div id="board"></div>
            </div>

            <div id="gameInfo">
                <div class="infoItem">
                    <div class="infoLabel">é»‘å­æ“’ç²</div>
                    <div class="infoValue">âš« <span id="blackCaptures">0</span></div>
                </div>
                <div class="infoItem">
                    <div class="infoLabel">ç™½å­æ“’ç²</div>
                    <div class="infoValue">âšª <span id="whiteCaptures">0</span></div>
                </div>
            </div>

            <div id="controls">
                <button class="controlButton" onclick="undoMove()">æ‚”æ£‹</button>
                <button class="controlButton pass" onclick="playerPass()">è™›æ‰‹</button>
                <button class="controlButton resign" id="resignButton" style="display:none;" onclick="confirmResign()">èªè¼¸</button>
            </div>
        </div>

        <div id="endGameModal">
            <div class="modalContent">
                <h2 class="modalTitle">å°å±€çµæŸ</h2>
                <div class="modalScore" id="finalScore"></div>
                <p style="font-size: 14px; color: #999; margin: -10px 0 15px 0;">ï¼ˆæ£‹ç›¤ä¸Šå·²æ¨™ç¤ºé ˜åœ°ï¼‰</p>
                
                <button class="expandButton" onclick="toggleExplanation()">
                    ç­è§£è¨ˆåˆ†æ–¹å¼
                </button>
                
                <div class="explanationSection" id="explanationSection">
                    <div class="explanationTitle">ğŸ“š åœæ£‹è¨ˆåˆ†èªªæ˜</div>
                    <div class="explanationContent">
                        <p><strong>åœæ£‹çš„ç›®æ¨™ï¼š</strong><br>
                        ä½”é ˜æ›´å¤šçš„åœ°ç›¤ï¼ˆç©ºåœ°ï¼‰ï¼ä¸åªæ˜¯åƒå­å–”ã€‚</p>
                        
                        <p><strong>å¦‚ä½•è¨ˆç®—åˆ†æ•¸ï¼š</strong><br>
                        ğŸ  <strong>é ˜åœ°</strong>ï¼šæ‚¨åœä½çš„ç©ºåœ°ï¼Œæ¯æ ¼ç®—1åˆ†<br>
                        âš« <strong>æ´»æ£‹</strong>ï¼šæ£‹ç›¤ä¸Šæ‚¨çš„æ£‹å­ï¼Œæ¯é¡†ç®—1åˆ†<br>
                        ğŸ¯ <strong>æå­</strong>ï¼šåƒæ‰å°æ–¹çš„æ£‹å­ï¼Œæ¯é¡†ç®—1åˆ†</p>
                        
                        <p><strong>è²¼ç›®æ˜¯ä»€éº¼ï¼Ÿ</strong><br>
                        å› ç‚ºé»‘æ£‹å…ˆä¸‹æœ‰å„ªå‹¢ï¼Œæ‰€ä»¥ç™½æ£‹æœƒå¾—åˆ°6.5åˆ†è£œå„Ÿï¼Œè®“éŠæˆ²æ›´å…¬å¹³ã€‚</p>
                        
                        <p><strong>èª°è´äº†ï¼Ÿ</strong><br>
                        ç¸½åˆ†é«˜çš„ä¸€æ–¹ç²å‹ï¼å°±é€™éº¼ç°¡å–®ã€‚</p>
                    </div>
                </div>
                
                <div class="scoreDetails">
                    <div class="scoreDetail black">
                        <span class="detailLabel">âš« é»‘å­è¨ˆåˆ†</span>
                        <span class="detailValue"></span>
                    </div>
                    <div class="scoreDetail black" id="blackTerritory">
                        <span class="detailLabel">ã€€ã€€é ˜åœ°</span>
                        <span class="detailValue">0 æ ¼</span>
                    </div>
                    <div class="scoreDetail black" id="blackStones">
                        <span class="detailLabel">ã€€ã€€æ´»æ£‹</span>
                        <span class="detailValue">0 å­</span>
                    </div>
                    <div class="scoreDetail black" id="blackCaptured">
                        <span class="detailLabel">ã€€ã€€æå­</span>
                        <span class="detailValue">0 å€‹</span>
                    </div>
                    <div class="scoreDetail black">
                        <span class="detailLabel"><strong>é»‘å­ç¸½åˆ†</strong></span>
                        <span class="detailValue" id="blackTotal"><strong>0</strong></span>
                    </div>
                    
                    <div style="margin: 15px 0;"></div>
                    
                    <div class="scoreDetail white">
                        <span class="detailLabel">âšª ç™½å­è¨ˆåˆ†</span>
                        <span class="detailValue"></span>
                    </div>
                    <div class="scoreDetail white" id="whiteTerritory">
                        <span class="detailLabel">ã€€ã€€é ˜åœ°</span>
                        <span class="detailValue">0 æ ¼</span>
                    </div>
                    <div class="scoreDetail white" id="whiteStones">
                        <span class="detailLabel">ã€€ã€€æ´»æ£‹</span>
                        <span class="detailValue">0 å­</span>
                    </div>
                    <div class="scoreDetail white" id="whiteCaptured">
                        <span class="detailLabel">ã€€ã€€æå­</span>
                        <span class="detailValue">0 å€‹</span>
                    </div>
                    <div class="scoreDetail white" id="whiteKomi">
                        <span class="detailLabel">ã€€ã€€è²¼ç›®</span>
                        <span class="detailValue">6.5 åˆ†</span>
                    </div>
                    <div class="scoreDetail white">
                        <span class="detailLabel"><strong>ç™½å­ç¸½åˆ†</strong></span>
                        <span class="detailValue" id="whiteTotal"><strong>0</strong></span>
                    </div>
                </div>
                
                <div class="modalMessage" id="endMessage"></div>
                <div class="modalButtons">
                    <button class="modalButton primary" onclick="newGame()">å†ä¾†ä¸€å±€</button>
                    <button class="modalButton secondary" onclick="takeBreak()">ä¼‘æ¯ä¸€ä¸‹</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const BOARD_SIZE = 13;
        const EMPTY = 0;
        const BLACK = 1;
        const WHITE = 2;

        let board = [];
        let currentPlayer = BLACK;
        let gameStarted = false;
        let blackCaptures = 0;
        let whiteCaptures = 0;
        let koPosition = null;
        let lastMove = null;
        let moveHistory = [];
        let passCount = 0;
        let gameCount = 0;
        let winCount = 0;
        let lossCount = 0;
        let gridEnabled = true;
        let difficulty = 'easy'; // easy, medium, hard
        let difficultyAdjustment = true; // Auto-adjust difficulty based on performance

        const aiMessages = {
            opening: [
                "æ‚¨çš„ä½ˆå±€å¾ˆå¥½ï¼",
                "æ¶å è§’è½ï¼Œé«˜æ˜ï¼",
                "æˆ‘ä¹Ÿè¦ä½”å€‹å¥½ä½ç½®",
                "æœ‰è¶£çš„é–‹å±€ï¼",
                "é€™æ­¥æ£‹å¾ˆç©©å¥"
            ],
            middle: [
                "æ¿€çƒˆçš„æˆ°é¬¥ï¼",
                "é€™æ­¥æ£‹å¾ˆå·§å¦™",
                "æˆ‘å¾—å°å¿ƒäº†",
                "å±€å‹¢è¶Šä¾†è¶Šæœ‰è¶£äº†",
                "æ‚¨çš„é€²æ”»å¾ˆçŒ›çƒˆï¼"
            ],
            capture: [
                "å“å‘€ï¼Œæˆ‘çš„æ£‹å­ï¼",
                "æ¼‚äº®çš„åƒå­ï¼",
                "æˆ‘è¦å ±ä»‡ï¼",
                "æ‚¨æŠ“ä½äº†å¥½æ™‚æ©Ÿï¼",
                "çœŸæ˜¯ç²¾å½©çš„æ‰‹ç­‹ï¼"
            ],
            endgame: [
                "å¿«åˆ†å‡ºå‹è² äº†",
                "é€™ç›¤æ£‹çœŸç²¾å½©",
                "æœ€å¾Œå¹¾æ­¥äº†",
                "æ”¶å®˜éšæ®µäº†",
                "å‹è² å³å°‡æ­æ›‰"
            ],
            encourage: [
                "ä¸éŒ¯ï¼ç¹¼çºŒåŠ æ²¹ï¼",
                "æ‚¨é€²æ­¥å¾ˆå¤šï¼",
                "é€™æ­¥æ£‹æœ‰æƒ³æ³•ï¼",
                "æ‚¨è¶Šä¸‹è¶Šå¥½äº†ï¼",
                "çœŸæ˜¯å¥½æ£‹ï¼"
            ],
            difficulty: {
                easy: ["æˆ‘å–œæ­¡å’Œå¹³çš„ä¸‹æ£‹", "è®“æˆ‘å€‘å„è‡ªå»ºç«‹åœ°ç›¤å§", "æˆ‘ä¸å¤ªå–œæ­¡æ‰“æ¶"],
                medium: ["æˆ‘æœƒå¥½å¥½å’Œæ‚¨è¼ƒé‡", "è®“æˆ‘å€‘äº’ç›¸å­¸ç¿’", "é€™å±€æœƒå¾ˆæœ‰æ„æ€"],
                hard: ["æˆ‘è¦å…¨åŠ›é€²æ”»ï¼", "æº–å‚™å¥½æ¿€çƒˆçš„æˆ°é¬¥äº†å—ï¼Ÿ", "æ¯å€‹å­éƒ½è¦çˆ­å¥ªï¼"]
            },
            peaceful: [
                "æˆ‘åœ¨è§’è½å»ºç«‹åŸºåœ°",
                "é€™é‚Šå¾ˆå®‰å…¨",
                "æˆ‘å–œæ­¡ç©©å®šçš„å½¢ç‹€",
                "æ…¢æ…¢æ“´å±•é ˜åœ°",
                "å’Œå¹³ç™¼å±•æœ€å¥½"
            ],
            aggressive: [
                "æˆ‘è¦åˆ‡æ–·æ‚¨çš„æ£‹ï¼",
                "é€²æ”»é–‹å§‹äº†ï¼",
                "é€™è£¡æœƒå¾ˆæ¿€çƒˆ",
                "ä¸è®“æ‚¨å®‰å¿ƒåšæ£‹",
                "æˆ°é¬¥ï¼æˆ°é¬¥ï¼",
                "æ‚¨çš„æ£‹å­å±éšªäº†ï¼",
                "æˆ‘è¦å…¥ä¾µé€™è£¡ï¼",
                "åˆ¥æƒ³è¼•é¬†å»ºåœ°ç›¤ï¼",
                "æ¯ä¸€æ­¥éƒ½æ˜¯æˆ°é¬¥ï¼",
                "çœ‹æˆ‘æ€éº¼æ”»ç ´æ‚¨çš„é˜²ç·šï¼"
            ],
            hardKill: [
                "å«åƒï¼æ‚¨çš„æ£‹å­è¦è¢«åƒäº†ï¼",
                "å“ˆå“ˆï¼æŠ“ä½äº†ï¼",
                "é€™ç¾¤æ£‹å­è·‘ä¸æ‰äº†ï¼",
                "çœ‹æ‚¨æ€éº¼æ•‘ï¼",
                "æ‚¨çš„å¤§é¾å±éšªäº†ï¼"
            ]
        };

        function initBoard() {
            board = [];
            for (let i = 0; i < BOARD_SIZE; i++) {
                board[i] = [];
                for (let j = 0; j < BOARD_SIZE; j++) {
                    board[i][j] = EMPTY;
                }
            }
            blackCaptures = 0;
            whiteCaptures = 0;
            koPosition = null;
            lastMove = null;
            moveHistory = [];
            passCount = 0;
            currentPlayer = BLACK;
            updateCaptures();
        }

        function createBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';

            // Apply grid class
            if (gridEnabled) {
                boardElement.classList.remove('no-grid');
            } else {
                boardElement.classList.add('no-grid');
            }

            // Always add grid lines (controlled by CSS opacity)
            for (let i = 0; i < BOARD_SIZE; i++) {
                // Horizontal lines
                const hLine = document.createElement('div');
                hLine.className = 'gridLine horizontal';
                hLine.style.top = `${(i / 12) * 100}%`;
                boardElement.appendChild(hLine);
                
                // Vertical lines
                const vLine = document.createElement('div');
                vLine.className = 'gridLine vertical';
                vLine.style.left = `${(i / 12) * 100}%`;
                boardElement.appendChild(vLine);
            }

            // Add star points
            const starPoints = [
                [3, 3], [3, 9], [6, 6], [9, 3], [9, 9]
            ];
            
            starPoints.forEach(([row, col]) => {
                const star = document.createElement('div');
                star.className = 'star-point';
                star.style.left = `${(col / 12) * 100}%`;
                star.style.top = `${(row / 12) * 100}%`;
                boardElement.appendChild(star);
            });

            // Create intersections
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    const intersection = document.createElement('div');
                    intersection.className = 'intersection';
                    intersection.style.left = `${(j / 12) * 100 - 3.845}%`;
                    intersection.style.top = `${(i / 12) * 100 - 3.845}%`;
                    intersection.dataset.row = i;
                    intersection.dataset.col = j;
                    
                    intersection.addEventListener('click', handleIntersectionClick);
                    intersection.addEventListener('touchstart', handleTouch, {passive: true});
                    intersection.addEventListener('touchend', handleTouchEnd, {passive: false});
                    
                    boardElement.appendChild(intersection);
                }
            }
        }

        function toggleGrid() {
            gridEnabled = !gridEnabled;
            const toggleButton = document.getElementById('gridToggle');
            const boardElement = document.getElementById('board');
            
            if (gridEnabled) {
                toggleButton.classList.add('active');
                toggleButton.textContent = 'é–‹å•Ÿ';
                boardElement.classList.remove('no-grid');
            } else {
                toggleButton.classList.remove('active');
                toggleButton.textContent = 'é—œé–‰';
                boardElement.classList.add('no-grid');
            }
        }

        function updateBoardStyle() {
            const boardContainer = document.getElementById('boardContainer');
            if (!boardContainer) return; // Safety check
            
            // Remove all mode classes
            boardContainer.classList.remove('easy-mode', 'medium-mode', 'hard-mode');
            
            // Add the appropriate mode class
            if (difficulty === 'easy') {
                boardContainer.classList.add('easy-mode');
            } else if (difficulty === 'medium') {
                boardContainer.classList.add('medium-mode');
            } else {
                boardContainer.classList.add('hard-mode');
            }
        }

        function changeDifficulty(level) {
            difficulty = level;
            
            // Update all button states
            document.querySelectorAll('.difficultyButton').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Set active button based on level
            if (level === 'easy') {
                document.querySelectorAll('.difficultyButton')[0].classList.add('active');
            } else if (level === 'medium') {
                document.querySelectorAll('.difficultyButton')[1].classList.add('active');
            } else if (level === 'hard') {
                document.querySelectorAll('.difficultyButton')[2].classList.add('active');
            }
            
            // Update hint text - directly set it based on level
            const hintElement = document.getElementById('difficultyHint');
            if (level === 'easy') {
                hintElement.textContent = 'å’Œå¹³å»ºè¨­';
                hintElement.style.color = '#4CAF50'; // Green
            } else if (level === 'medium') {
                hintElement.textContent = 'æ”»å®ˆå¹³è¡¡';
                hintElement.style.color = '#FF9800'; // Orange
            } else if (level === 'hard') {
                hintElement.textContent = 'æ¿€çƒˆæˆ°é¬¥';
                hintElement.style.color = '#F44336'; // Red
            }
            
            // Update board style
            updateBoardStyle();
            
            // Show personality message with extreme descriptions
            let personalityMessage = "";
            if (level === 'easy') {
                personalityMessage = "å’Œå¹³æ¨¡å¼ï¼šæˆ‘æœƒèº²åœ¨è§’è½å»ºè¨­ï¼Œçµ•å°ä¸æœƒä¸»å‹•æ”»æ“Šæ‚¨";
            } else if (level === 'medium') {
                personalityMessage = "å¹³è¡¡æ¨¡å¼ï¼šæˆ‘æœƒæ”»å®ˆå…¼å‚™ï¼Œçœ‹æº–æ™‚æ©Ÿé€²æ”»";
            } else if (level === 'hard') {
                personalityMessage = "æˆ°é¬¥ç‹‚æ¨¡å¼ï¼šæˆ‘æœƒç˜‹ç‹‚é€²æ”»ï¼æ¯ä¸€æ‰‹éƒ½åœ¨æ‰¾æ©Ÿæœƒæ®ºæ‚¨çš„æ£‹ï¼";
            }
            
            showMessage(personalityMessage);
            
            // Turn off auto-adjustment when manually set
            difficultyAdjustment = false;
        }

        function setDifficulty(level) {
            difficulty = level;
            
            // Update button states
            document.querySelectorAll('.difficultyButton').forEach(btn => {
                btn.classList.remove('active');
                if ((level === 'easy' && btn.textContent === 'ç°¡å–®') ||
                    (level === 'medium' && btn.textContent === 'ä¸­ç­‰') ||
                    (level === 'hard' && btn.textContent === 'å›°é›£')) {
                    btn.classList.add('active');
                }
            });
            
            // Show personality-based message
            let personalityMessage = "";
            if (level === 'easy') {
                personalityMessage = "æˆ‘æœƒå’Œå¹³åœ°å»ºç«‹è‡ªå·±çš„åœ°ç›¤ï¼Œä¸å¤ªæœƒæ”»æ“Šæ‚¨";
            } else if (level === 'medium') {
                personalityMessage = "æˆ‘æœƒå¹³è¡¡é€²æ”»å’Œé˜²å®ˆï¼Œå°‹æ‰¾å¥½æ©Ÿæœƒ";
            } else {
                personalityMessage = "æˆ‘æœƒç©æ¥µé€²æ”»ï¼Œæ¯å€‹åœ°æ–¹éƒ½è¦æˆ°é¬¥ï¼";
            }
            
            showMessage(personalityMessage);
            
            // Turn off auto-adjustment when manually set
            difficultyAdjustment = false;
        }

        function adjustDifficultyAutomatically() {
            if (!difficultyAdjustment) return;
            
            // Auto-adjust based on win/loss ratio
            const totalGames = winCount + lossCount;
            if (totalGames >= 3) {
                const winRate = winCount / totalGames;
                
                if (winRate > 0.7 && difficulty !== 'hard') {
                    // Player winning too much, increase difficulty
                    if (difficulty === 'easy') {
                        setDifficultyLevel('medium');
                        setTimeout(() => showMessage("æ‚¨å¾ˆå²å®³ï¼ä¸‹ä¸€å±€æˆ‘æœƒæ›´ä¸»å‹•é€²æ”»"), 2000);
                    } else if (difficulty === 'medium') {
                        setDifficultyLevel('hard');
                        setTimeout(() => showMessage("æ‚¨çœŸæ˜¯é«˜æ‰‹ï¼ä¸‹ä¸€å±€æˆ‘è¦å…¨åŠ›æˆ°é¬¥äº†ï¼"), 2000);
                    }
                    difficultyAdjustment = true; // Keep auto-adjustment on
                } else if (winRate < 0.3 && difficulty !== 'easy') {
                    // Player losing too much, decrease difficulty
                    if (difficulty === 'hard') {
                        setDifficultyLevel('medium');
                        setTimeout(() => showMessage("æˆ‘å¤ªå…‡çŒ›äº†ï¼Œä¸‹ä¸€å±€æº«å’Œä¸€é»"), 2000);
                    } else if (difficulty === 'medium') {
                        setDifficultyLevel('easy');
                        setTimeout(() => showMessage("è®“æˆ‘å€‘å’Œå¹³åœ°ä¸‹æ£‹ï¼Œå„è‡ªç™¼å±•"), 2000);
                    }
                    difficultyAdjustment = true; // Keep auto-adjustment on
                }
            }
        }

        function setDifficultyLevel(level) {
            difficulty = level;
            
            // Update button states
            document.querySelectorAll('.difficultyButton').forEach(btn => {
                btn.classList.remove('active');
                if ((level === 'easy' && btn.textContent === 'ç°¡å–®') ||
                    (level === 'medium' && btn.textContent === 'ä¸­ç­‰') ||
                    (level === 'hard' && btn.textContent === 'å›°é›£')) {
                    btn.classList.add('active');
                }
            });
        }

        let touchedIntersection = null;

        function handleTouch(e) {
            const intersection = e.currentTarget;
            const row = parseInt(intersection.dataset.row);
            const col = parseInt(intersection.dataset.col);
            
            if (currentPlayer === BLACK && board[row][col] === EMPTY) {
                touchedIntersection = intersection;
                showPreview(intersection, row, col);
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (touchedIntersection) {
                const row = parseInt(touchedIntersection.dataset.row);
                const col = parseInt(touchedIntersection.dataset.col);
                removePreview(touchedIntersection);
                placeStone(row, col);
                touchedIntersection = null;
            }
        }

        function showPreview(intersection, row, col) {
            if (board[row][col] === EMPTY && currentPlayer === BLACK) {
                const stone = document.createElement('div');
                stone.className = 'stone black preview';
                intersection.appendChild(stone);
            }
        }

        function removePreview(intersection) {
            const preview = intersection.querySelector('.preview');
            if (preview) {
                preview.remove();
            }
        }

        function handleIntersectionClick(e) {
            const intersection = e.currentTarget;
            const row = parseInt(intersection.dataset.row);
            const col = parseInt(intersection.dataset.col);
            
            if (currentPlayer === BLACK) {
                placeStone(row, col);
            }
        }

        function placeStone(row, col) {
            if (!gameStarted || currentPlayer !== BLACK) return;
            if (board[row][col] !== EMPTY) return;
            
            // Check ko rule
            if (koPosition && koPosition.row === row && koPosition.col === col) {
                showMessage("é‚£è£¡ä¸èƒ½ä¸‹å–”ï¼Œè©¦è©¦å…¶ä»–åœ°æ–¹ï¼");
                return;
            }

            // Try placing the stone
            board[row][col] = BLACK;
            
            // Check for captures
            const captures = checkCaptures(row, col, WHITE);
            
            // Check for suicide
            if (!hasLiberties(row, col, BLACK) && captures.length === 0) {
                board[row][col] = EMPTY;
                showMessage("é‚£è£¡ä¸èƒ½ä¸‹å–”ï¼Œè©¦è©¦å…¶ä»–åœ°æ–¹ï¼");
                return;
            }

            // Valid move
            passCount = 0;
            
            // Handle captures
            if (captures.length > 0) {
                captures.forEach(([r, c]) => {
                    board[r][c] = EMPTY;
                    blackCaptures++;
                });
                
                // Check for ko
                if (captures.length === 1 && !hasLiberties(row, col, BLACK)) {
                    koPosition = { row: captures[0][0], col: captures[0][1] };
                } else {
                    koPosition = null;
                }
                
                updateCaptures();
                showMessage(getRandomMessage('capture'));
            } else {
                koPosition = null;
                const moveCount = moveHistory.length;
                if (moveCount < 10) {
                    showMessage(getRandomMessage('opening'));
                } else if (moveCount < 50) {
                    showMessage(getRandomMessage('middle'));
                } else {
                    showMessage(getRandomMessage('endgame'));
                }
            }

            lastMove = { row, col };
            moveHistory.push({ row, col, player: BLACK });
            renderBoard();
            currentPlayer = WHITE;
            
            setTimeout(makeAIMove, 1000);
        }

        function hasLiberties(row, col, color) {
            const visited = new Set();
            return checkGroupLiberties(row, col, color, visited) > 0;
        }

        function checkGroupLiberties(row, col, color, visited) {
            if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) return 0;
            
            const key = `${row},${col}`;
            if (visited.has(key)) return 0;
            
            if (board[row][col] === EMPTY) return 1;
            if (board[row][col] !== color) return 0;
            
            visited.add(key);
            
            let liberties = 0;
            const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
            
            for (const [dr, dc] of neighbors) {
                liberties += checkGroupLiberties(row + dr, col + dc, color, visited);
            }
            
            return liberties;
        }

        function checkCaptures(row, col, opponentColor) {
            const captures = [];
            const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
            
            for (const [dr, dc] of neighbors) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (newRow >= 0 && newRow < BOARD_SIZE && 
                    newCol >= 0 && newCol < BOARD_SIZE &&
                    board[newRow][newCol] === opponentColor) {
                    
                    if (!hasLiberties(newRow, newCol, opponentColor)) {
                        const group = getGroup(newRow, newCol, opponentColor);
                        captures.push(...group);
                    }
                }
            }
            
            return captures;
        }

        function getGroup(row, col, color) {
            const group = [];
            const visited = new Set();
            const stack = [[row, col]];
            
            while (stack.length > 0) {
                const [r, c] = stack.pop();
                const key = `${r},${c}`;
                
                if (visited.has(key)) continue;
                visited.add(key);
                
                if (board[r][c] === color) {
                    group.push([r, c]);
                    
                    const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
                    for (const [dr, dc] of neighbors) {
                        const newRow = r + dr;
                        const newCol = c + dc;
                        if (newRow >= 0 && newRow < BOARD_SIZE && 
                            newCol >= 0 && newCol < BOARD_SIZE) {
                            stack.push([newRow, newCol]);
                        }
                    }
                }
            }
            
            return group;
        }

        function evaluateMove(row, col, color) {
            // Advanced move evaluation for better AI
            let score = 0;
            
            // Check captures
            const captures = checkCaptures(row, col, color === WHITE ? BLACK : WHITE);
            score += captures.length * 50;
            
            // Count liberties after the move
            board[row][col] = color;
            const liberties = countGroupLiberties(row, col, color);
            board[row][col] = EMPTY;
            score += liberties * 5;
            
            // Distance from edges (center is often strategic in middle game)
            const distFromEdge = Math.min(row, col, BOARD_SIZE - 1 - row, BOARD_SIZE - 1 - col);
            
            // Opening strategy - corners and sides
            if (moveHistory.length < 15) {
                if ((row <= 3 || row >= 9) && (col <= 3 || col >= 9)) {
                    score += 25; // Corner area
                }
                if (row <= 1 || row >= 11 || col <= 1 || col >= 11) {
                    score += 15; // Edge area
                }
            } else {
                // Middle game - balance center and sides
                score += distFromEdge * 2;
            }
            
            // Connection to friendly stones
            const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
            let friendlyNeighbors = 0;
            let enemyNeighbors = 0;
            
            for (const [dr, dc] of neighbors) {
                const nr = row + dr;
                const nc = col + dc;
                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                    if (board[nr][nc] === color) friendlyNeighbors++;
                    else if (board[nr][nc] !== EMPTY) enemyNeighbors++;
                }
            }
            
            score += friendlyNeighbors * 8;
            
            // Check if move threatens enemy groups
            for (const [dr, dc] of neighbors) {
                const nr = row + dr;
                const nc = col + dc;
                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                    if (board[nr][nc] === (color === WHITE ? BLACK : WHITE)) {
                        // Temporarily place stone to check enemy liberties
                        board[row][col] = color;
                        const enemyLiberties = countGroupLiberties(nr, nc, board[nr][nc]);
                        board[row][col] = EMPTY;
                        
                        if (enemyLiberties === 1) score += 40; // Atari!
                        else if (enemyLiberties === 2) score += 20; // Threatening
                    }
                }
            }
            
            return score;
        }

        function countGroupLiberties(row, col, color) {
            const visited = new Set();
            const liberties = new Set();
            
            function explore(r, c) {
                if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) return;
                
                const key = `${r},${c}`;
                if (visited.has(key)) return;
                
                if (board[r][c] === EMPTY) {
                    liberties.add(key);
                    return;
                }
                
                if (board[r][c] !== color) return;
                
                visited.add(key);
                
                const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
                for (const [dr, dc] of neighbors) {
                    explore(r + dr, c + dc);
                }
            }
            
            explore(row, col);
            return liberties.size;
        }

        function makeAIMove() {
            if (!gameStarted || currentPlayer !== WHITE) return;

            const validMoves = [];
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === EMPTY) {
                        // Check if move is legal
                        board[i][j] = WHITE;
                        const captures = checkCaptures(i, j, BLACK);
                        const wouldBeSuicide = !hasLiberties(i, j, WHITE) && captures.length === 0;
                        const isKo = koPosition && koPosition.row === i && koPosition.col === j;
                        
                        if (!wouldBeSuicide && !isKo) {
                            // Calculate score based on difficulty
                            let score = evaluateMove(i, j, WHITE);
                            
                            // Difficulty-based adjustments
                            if (difficulty === 'easy') {
                                // Easy mode: Peaceful, avoid confrontation
                                // Prefer empty corners and building territory
                                const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
                                let hasEnemyNeighbor = false;
                                for (const [dr, dc] of neighbors) {
                                    const nr = i + dr;
                                    const nc = j + dc;
                                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                                        if (board[nr][nc] === BLACK) {
                                            hasEnemyNeighbor = true;
                                            break;
                                        }
                                    }
                                }
                                
                                if (hasEnemyNeighbor) {
                                    score -= 30; // Avoid playing near opponent
                                }
                                
                                // Strongly prefer corners and peaceful areas
                                if ((i <= 2 || i >= 10) && (j <= 2 || j >= 10)) {
                                    score += 40;
                                }
                                
                                // Add more randomness
                                score += Math.random() * 20;
                                
                            } else if (difficulty === 'medium') {
                                // Medium mode: Balanced play
                                // Standard evaluation with some randomness
                                score += Math.random() * 10;
                                
                            } else if (difficulty === 'hard') {
                                // Hard mode: Aggressive, seeks fights
                                // Look for cutting and attacking moves
                                const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
                                
                                // Bonus for playing near opponent stones
                                for (const [dr, dc] of neighbors) {
                                    const nr = i + dr;
                                    const nc = j + dc;
                                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                                        if (board[nr][nc] === BLACK) {
                                            score += 25; // Seek contact
                                            
                                            // Check if we can reduce their liberties
                                            board[i][j] = WHITE;
                                            const enemyLibs = countGroupLiberties(nr, nc, BLACK);
                                            board[i][j] = EMPTY;
                                            
                                            if (enemyLibs <= 2) {
                                                score += 50; // Attack weak groups
                                            }
                                        }
                                    }
                                }
                                
                                // Look for cutting points
                                let blackDiagonals = 0;
                                const diagonals = [[1,1], [1,-1], [-1,1], [-1,-1]];
                                for (const [dr, dc] of diagonals) {
                                    const nr = i + dr;
                                    const nc = j + dc;
                                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                                        if (board[nr][nc] === BLACK) blackDiagonals++;
                                    }
                                }
                                if (blackDiagonals >= 2) {
                                    score += 30; // Potential cutting point
                                }
                                
                                // Less randomness for more consistent aggression
                                score += Math.random() * 5;
                            }
                            
                            validMoves.push({ row: i, col: j, score, captures: captures.length });
                        }
                        
                        board[i][j] = EMPTY;
                    }
                }
            }

            if (validMoves.length === 0) {
                aiPass();
                return;
            }

            // Sort by score
            validMoves.sort((a, b) => b.score - a.score);
            
            // Pick from top moves based on difficulty
            let move;
            if (difficulty === 'easy') {
                // More random, sometimes makes weak moves
                const topMoves = validMoves.slice(0, Math.min(10, validMoves.length));
                move = topMoves[Math.floor(Math.random() * topMoves.length)];
            } else if (difficulty === 'medium') {
                // Balanced selection from top moves
                const topMoves = validMoves.slice(0, Math.min(5, validMoves.length));
                move = topMoves[Math.floor(Math.random() * topMoves.length)];
            } else {
                // Hard mode: Usually picks best move
                if (Math.random() < 0.8) {
                    move = validMoves[0]; // Best move
                } else {
                    const topMoves = validMoves.slice(0, Math.min(3, validMoves.length));
                    move = topMoves[Math.floor(Math.random() * topMoves.length)];
                }
            }

            board[move.row][move.col] = WHITE;
            
            const captures = checkCaptures(move.row, move.col, BLACK);
            if (captures.length > 0) {
                captures.forEach(([r, c]) => {
                    board[r][c] = EMPTY;
                    whiteCaptures++;
                });
                
                if (captures.length === 1 && !hasLiberties(move.row, move.col, WHITE)) {
                    koPosition = { row: captures[0][0], col: captures[0][1] };
                } else {
                    koPosition = null;
                }
                
                updateCaptures();
                
                // Capture messages based on difficulty
                if (difficulty === 'hard' && captures.length > 1) {
                    showMessage(getRandomMessage('hardKill'));
                } else {
                    showMessage("æˆ‘åƒæ‰äº†æ‚¨çš„æ£‹å­ï¼");
                }
            } else {
                koPosition = null;
                
                // Context-aware messages based on difficulty and game phase
                if (difficulty === 'easy') {
                    if (moveHistory.length < 10) {
                        showMessage(getRandomMessage('peaceful'));
                    } else if (Math.random() < 0.3) {
                        showMessage(getRandomMessage('encourage'));
                    }
                } else if (difficulty === 'hard') {
                    // Check if we're threatening opponent stones
                    let threatening = false;
                    const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
                    for (const [dr, dc] of neighbors) {
                        const nr = move.row + dr;
                        const nc = move.col + dc;
                        if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE &&
                            board[nr][nc] === BLACK) {
                            const libs = countGroupLiberties(nr, nc, BLACK);
                            if (libs <= 2) {
                                threatening = true;
                                break;
                            }
                        }
                    }
                    
                    if (threatening) {
                        showMessage(getRandomMessage('aggressive'));
                    } else if (moveHistory.length < 10) {
                        showMessage("æˆ‘è¦æ§åˆ¶é€™å€‹å€åŸŸï¼");
                    }
                } else {
                    // Medium difficulty - balanced messages
                    if (moveHistory.length < 10) {
                        showMessage("æˆ‘ä¹Ÿä½”å€‹å¥½ä½ç½®");
                    } else if (Math.random() < 0.2) {
                        showMessage(getRandomMessage('middle'));
                    }
                }
            }

            passCount = 0;
            lastMove = { row: move.row, col: move.col };
            moveHistory.push({ row: move.row, col: move.col, player: WHITE });
            renderBoard();
            currentPlayer = BLACK;
        }

        function renderBoard() {
            const intersections = document.querySelectorAll('.intersection');
            
            intersections.forEach(intersection => {
                const row = parseInt(intersection.dataset.row);
                const col = parseInt(intersection.dataset.col);
                
                // Clear existing stones
                intersection.innerHTML = '';
                
                if (board[row][col] !== EMPTY) {
                    const stone = document.createElement('div');
                    stone.className = `stone ${board[row][col] === BLACK ? 'black' : 'white'}`;
                    
                    if (lastMove && lastMove.row === row && lastMove.col === col) {
                        stone.classList.add('last-move');
                    }
                    
                    intersection.appendChild(stone);
                }
            });
        }

        function playerPass() {
            if (!gameStarted || currentPlayer !== BLACK) return;
            
            passCount++;
            showMessage("æ‚¨è™›æ‰‹äº†ï¼Œè¼ªåˆ°æˆ‘");
            currentPlayer = WHITE;
            
            if (passCount >= 2) {
                endGame();
            } else {
                setTimeout(makeAIMove, 1000);
            }
        }

        function aiPass() {
            passCount++;
            showMessage("æˆ‘ä¹Ÿè™›æ‰‹ï¼Œå°å±€çµæŸï¼");
            currentPlayer = BLACK;
            
            if (passCount >= 2) {
                endGame();
            }
        }

        function undoMove() {
            if (moveHistory.length < 2 || currentPlayer !== BLACK) return;
            
            // Remove last two moves (AI and player)
            moveHistory.pop();
            moveHistory.pop();
            
            // Rebuild board from history
            initBoard();
            for (const move of moveHistory) {
                board[move.row][move.col] = move.player;
            }
            
            renderBoard();
            showMessage("å¥½çš„ï¼Œè®“æ‚¨é‡æ–°è€ƒæ…®");
            currentPlayer = BLACK;
        }

        function calculateScore() {
            // Mark territories first
            const territoryMap = markTerritory();
            
            let blackTerritory = 0;
            let whiteTerritory = 0;
            let blackStoneCount = 0;
            let whiteStoneCount = 0;
            
            // Count stones and territories
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === BLACK) {
                        blackStoneCount++;
                    } else if (board[i][j] === WHITE) {
                        whiteStoneCount++;
                    } else if (board[i][j] === EMPTY) {
                        if (territoryMap[i][j] === BLACK) {
                            blackTerritory++;
                        } else if (territoryMap[i][j] === WHITE) {
                            whiteTerritory++;
                        }
                    }
                }
            }
            
            // Calculate final scores using Chinese rules
            const blackTotal = blackTerritory + blackStoneCount + blackCaptures;
            const whiteTotal = whiteTerritory + whiteStoneCount + whiteCaptures + 6.5;
            
            return {
                black: {
                    territory: blackTerritory,
                    stones: blackStoneCount,
                    captures: blackCaptures,
                    total: blackTotal
                },
                white: {
                    territory: whiteTerritory,
                    stones: whiteStoneCount,
                    captures: whiteCaptures,
                    komi: 6.5,
                    total: whiteTotal
                },
                territoryMap: territoryMap
            };
        }

        function markTerritory() {
            const territory = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));
            const visited = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(false));
            
            // Find all empty regions and determine their owner
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === EMPTY && !visited[i][j]) {
                        const region = [];
                        const owner = floodFillTerritory(i, j, visited, region);
                        
                        // Mark the region with the owner's color
                        for (const [r, c] of region) {
                            territory[r][c] = owner;
                        }
                    }
                }
            }
            
            // Second pass: For small enclosed areas, use proximity-based assignment
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === EMPTY && territory[i][j] === EMPTY) {
                        // This empty point is disputed, assign based on influence
                        territory[i][j] = getInfluenceBasedOwner(i, j);
                    }
                }
            }
            
            return territory;
        }

        function floodFillTerritory(startRow, startCol, visited, region) {
            const stack = [[startRow, startCol]];
            const touchingColors = new Set();
            const boundaryStones = [];
            
            while (stack.length > 0) {
                const [row, col] = stack.pop();
                
                if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
                    continue;
                }
                
                if (visited[row][col]) continue;
                
                if (board[row][col] === EMPTY) {
                    visited[row][col] = true;
                    region.push([row, col]);
                    
                    // Check all neighbors
                    const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
                    for (const [dr, dc] of neighbors) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        
                        if (newRow >= 0 && newRow < BOARD_SIZE && 
                            newCol >= 0 && newCol < BOARD_SIZE) {
                            
                            if (board[newRow][newCol] !== EMPTY) {
                                touchingColors.add(board[newRow][newCol]);
                                boundaryStones.push({color: board[newRow][newCol], row: newRow, col: newCol});
                            } else if (!visited[newRow][newCol]) {
                                stack.push([newRow, newCol]);
                            }
                        }
                    }
                }
            }
            
            // If the region touches only one color, that player owns it
            if (touchingColors.size === 1) {
                return touchingColors.values().next().value;
            }
            
            // If region is small and mostly surrounded by one color, assign to that color
            if (region.length <= 4) {
                let blackBoundary = 0;
                let whiteBoundary = 0;
                for (const stone of boundaryStones) {
                    if (stone.color === BLACK) blackBoundary++;
                    else whiteBoundary++;
                }
                
                // If 75% or more of boundary is one color, assign to that color
                const totalBoundary = blackBoundary + whiteBoundary;
                if (blackBoundary >= totalBoundary * 0.75) return BLACK;
                if (whiteBoundary >= totalBoundary * 0.75) return WHITE;
            }
            
            // Otherwise it's neutral/disputed
            return EMPTY;
        }

        function getInfluenceBasedOwner(row, col) {
            // Calculate influence based on nearby stones
            let blackInfluence = 0;
            let whiteInfluence = 0;
            
            // Check in a 3x3 area around the point
            for (let dr = -2; dr <= 2; dr++) {
                for (let dc = -2; dc <= 2; dc++) {
                    const r = row + dr;
                    const c = col + dc;
                    if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                        if (board[r][c] === BLACK) {
                            const distance = Math.abs(dr) + Math.abs(dc);
                            blackInfluence += (3 - Math.min(distance, 3));
                        } else if (board[r][c] === WHITE) {
                            const distance = Math.abs(dr) + Math.abs(dc);
                            whiteInfluence += (3 - Math.min(distance, 3));
                        }
                    }
                }
            }
            
            // Assign to the color with more influence
            if (blackInfluence > whiteInfluence + 2) return BLACK;
            if (whiteInfluence > blackInfluence + 2) return WHITE;
            
            // If influence is very close, check immediate neighbors only
            const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
            let blackNeighbors = 0;
            let whiteNeighbors = 0;
            
            for (const [dr, dc] of neighbors) {
                const nr = row + dr;
                const nc = col + dc;
                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                    if (board[nr][nc] === BLACK) blackNeighbors++;
                    else if (board[nr][nc] === WHITE) whiteNeighbors++;
                }
            }
            
            if (blackNeighbors > whiteNeighbors) return BLACK;
            if (whiteNeighbors > blackNeighbors) return WHITE;
            
            // Still can't decide - remain neutral
            return EMPTY;
        }

        function showTerritories(territoryMap) {
            // Remove old territory markers
            document.querySelectorAll('.territoryOverlay').forEach(el => el.remove());
            
            const boardElement = document.getElementById('board');
            if (!boardElement) return;
            
            // Count territories for debugging
            let blackTerritoryCount = 0;
            let whiteTerritoryCount = 0;
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === EMPTY && territoryMap[i][j] !== EMPTY) {
                        const overlay = document.createElement('div');
                        overlay.className = `territoryOverlay ${territoryMap[i][j] === BLACK ? 'black-territory' : 'white-territory'}`;
                        overlay.style.position = 'absolute';
                        // Adjust positioning to center on intersection
                        overlay.style.left = `${(j / 12) * 100 - 3}%`;
                        overlay.style.top = `${(i / 12) * 100 - 3}%`;
                        overlay.style.width = '6%';
                        overlay.style.height = '6%';
                        boardElement.appendChild(overlay);
                        
                        if (territoryMap[i][j] === BLACK) blackTerritoryCount++;
                        else if (territoryMap[i][j] === WHITE) whiteTerritoryCount++;
                    }
                }
            }
            
            console.log(`Territories marked - Black: ${blackTerritoryCount}, White: ${whiteTerritoryCount}`);
        }

        function clearTerritories() {
            document.querySelectorAll('.territoryOverlay').forEach(el => el.remove());
        }

        function toggleExplanation() {
            const button = event.target;
            const section = document.getElementById('explanationSection');
            
            button.classList.toggle('expanded');
            section.classList.toggle('show');
            
            if (section.classList.contains('show')) {
                button.textContent = 'æ”¶èµ·èªªæ˜';
            } else {
                button.textContent = 'ç­è§£è¨ˆåˆ†æ–¹å¼';
            }
        }

        function endGame() {
            gameStarted = false;
            const scoreData = calculateScore();
            const winner = scoreData.black.total > scoreData.white.total ? 'black' : 'white';
            const difference = Math.abs(scoreData.black.total - scoreData.white.total);
            
            // Show territories on the board
            showTerritories(scoreData.territoryMap);
            
            gameCount++;
            if (winner === 'black') {
                winCount++;
            } else {
                lossCount++;
            }

            // Auto-adjust difficulty if enabled
            adjustDifficultyAutomatically();

            const modal = document.getElementById('endGameModal');
            const finalScore = document.getElementById('finalScore');
            const endMessage = document.getElementById('endMessage');
            
            // Update summary score
            finalScore.textContent = `é»‘: ${scoreData.black.total.toFixed(1)} ç™½: ${scoreData.white.total.toFixed(1)}`;
            
            // Update detailed breakdown
            document.querySelector('#blackTerritory .detailValue').textContent = `${scoreData.black.territory} æ ¼`;
            document.querySelector('#blackStones .detailValue').textContent = `${scoreData.black.stones} å­`;
            document.querySelector('#blackCaptured .detailValue').textContent = `${scoreData.black.captures} å€‹`;
            document.getElementById('blackTotal').textContent = scoreData.black.total.toFixed(1);
            
            document.querySelector('#whiteTerritory .detailValue').textContent = `${scoreData.white.territory} æ ¼`;
            document.querySelector('#whiteStones .detailValue').textContent = `${scoreData.white.stones} å­`;
            document.querySelector('#whiteCaptured .detailValue').textContent = `${scoreData.white.captures} å€‹`;
            document.getElementById('whiteTotal').textContent = scoreData.white.total.toFixed(1);
            
            // Personality-based end messages
            let personalityText = "";
            if (difficulty === 'easy') {
                personalityText = winner === 'black' ? 
                    "æ‚¨è´äº†ï¼æˆ‘çš„å’Œå¹³ç­–ç•¥æ²’æˆåŠŸå‘¢" : 
                    "æˆ‘é è‘—ç©©å®šçš„åœ°ç›¤è´äº†ï¼Œä½†æ‚¨ä¸‹å¾—å¾ˆå¥½ï¼";
            } else if (difficulty === 'medium') {
                personalityText = winner === 'black' ? 
                    "ç²¾å½©çš„å°å±€ï¼æ‚¨çš„ç­–ç•¥æ›´å‹ä¸€ç±Œï¼" : 
                    "é€™æ¬¡æˆ‘è´äº†ï¼Œä½†å°å±€å¾ˆç²¾å½©ï¼";
            } else {
                personalityText = winner === 'black' ? 
                    "æ‚¨åœ¨æ¿€çƒˆçš„æˆ°é¬¥ä¸­ç²å‹äº†ï¼çœŸå²å®³ï¼" : 
                    "æ¿€çƒˆçš„æˆ°é¬¥å¾Œï¼Œæˆ‘éšªå‹äº†ï¼";
            }
            
            if (winner === 'black') {
                endMessage.textContent = `${personalityText} æ‚¨è´äº†${difference.toFixed(1)}ç›®ï¼ä»Šæ—¥æˆ°ç¸¾: ${winCount}å‹${lossCount}è² `;
            } else {
                endMessage.textContent = `${personalityText} æˆ‘è´äº†${difference.toFixed(1)}ç›®ã€‚ä»Šæ—¥æˆ°ç¸¾: ${winCount}å‹${lossCount}è² `;
            }
            
            modal.style.display = 'flex';
        }

        function newGame() {
            document.getElementById('endGameModal').style.display = 'none';
            
            // Clear territory markings from previous game
            clearTerritories();
            
            initBoard();
            renderBoard();
            gameStarted = true;
            
            // Reset explanation section
            const explanationSection = document.getElementById('explanationSection');
            const expandButton = document.querySelector('.expandButton');
            explanationSection.classList.remove('show');
            expandButton.classList.remove('expanded');
            expandButton.textContent = 'ç­è§£è¨ˆåˆ†æ–¹å¼';
            
            if (gameCount > 0 && gameCount % 5 === 0) {
                showMessage("æ‚¨ä»Šå¤©ä¸‹äº†5å±€äº†ï¼Œè¦ä¸è¦ä¼‘æ¯ä¸€ä¸‹ï¼Ÿ");
            } else {
                showMessage("æ–°çš„ä¸€å±€é–‹å§‹ï¼æ‚¨åŸ·é»‘å­å…ˆä¸‹ã€‚");
            }
        }

        function takeBreak() {
            document.getElementById('endGameModal').style.display = 'none';
            clearTerritories();
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('welcomeScreen').style.display = 'block';
            
            const welcomeMessage = document.querySelector('.welcomeMessage');
            welcomeMessage.innerHTML = `æ­¡è¿å›ä¾†ï¼<br>ä»Šæ—¥æˆ°ç¸¾: ${winCount}å‹${lossCount}è² <br>æº–å‚™å¥½å†ä¾†ä¸€å±€äº†å—ï¼Ÿ`;
        }

        function showMessage(message) {
            document.getElementById('aiMessage').textContent = message;
        }

        function getRandomMessage(category) {
            const messages = aiMessages[category];
            return messages[Math.floor(Math.random() * messages.length)];
        }

        function updateCaptures() {
            document.getElementById('blackCaptures').textContent = blackCaptures;
            document.getElementById('whiteCaptures').textContent = whiteCaptures;
        }

        function startGame() {
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            initBoard();
            createBoard();
            renderBoard();
            gameStarted = true;
            
            // Enable auto-adjustment for new session
            if (gameCount === 0) {
                difficultyAdjustment = true;
            }
            
            // Initialize settings UI
            const gridToggle = document.getElementById('gridToggle');
            if (gridEnabled) {
                gridToggle.classList.add('active');
                gridToggle.textContent = 'é–‹å•Ÿ';
            } else {
                gridToggle.classList.remove('active');
                gridToggle.textContent = 'é—œé–‰';
            }
            
            // Set initial difficulty buttons and hint
            document.querySelectorAll('.difficultyButton').forEach((btn, index) => {
                btn.classList.remove('active');
                if ((difficulty === 'easy' && index === 0) ||
                    (difficulty === 'medium' && index === 1) ||
                    (difficulty === 'hard' && index === 2)) {
                    btn.classList.add('active');
                }
            });
            
            // Set difficulty hint text with color - directly based on difficulty variable
            const hintElement = document.getElementById('difficultyHint');
            if (hintElement) {
                if (difficulty === 'easy') {
                    hintElement.textContent = 'å’Œå¹³å»ºè¨­';
                    hintElement.style.color = '#4CAF50';
                } else if (difficulty === 'medium') {
                    hintElement.textContent = 'æ”»å®ˆå¹³è¡¡';
                    hintElement.style.color = '#FF9800';
                } else if (difficulty === 'hard') {
                    hintElement.textContent = 'æ¿€çƒˆæˆ°é¬¥';
                    hintElement.style.color = '#F44336';
                }
            }
            
            // Set board style based on difficulty
            updateBoardStyle();
            
            if (gameCount === 0) {
                showMessage("æ‚¨åŸ·é»‘å­ï¼Œè«‹å…ˆä¸‹ï¼è§¸ç¢°ä»»ä½•äº¤å‰é»è½å­ã€‚");
            } else {
                let personalityText = "";
                if (difficulty === 'easy') {
                    personalityText = "ï¼ˆå’Œå¹³æ¨¡å¼ï¼‰æˆ‘æœƒåœ¨è‡ªå·±çš„è§’è½å®‰éœå»ºåœ°ç›¤";
                } else if (difficulty === 'medium') {
                    personalityText = "ï¼ˆå¹³è¡¡æ¨¡å¼ï¼‰æˆ‘æœƒèªçœŸå’Œæ‚¨å°å¼ˆ";
                } else {
                    personalityText = "ï¼ˆæˆ°é¬¥ç‹‚æ¨¡å¼ï¼‰æˆ‘è¦å¾ç¬¬ä¸€æ‰‹å°±é–‹å§‹é€²æ”»ï¼";
                }
                showMessage(`ç¬¬${gameCount + 1}å±€é–‹å§‹ï¼${personalityText}`);
            }
        }

        // Prevent zooming on double tap
        document.addEventListener('touchend', function(e) {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        let lastTouchEnd = 0;
    </script>
</body>
</html>