<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>圍棋 - 與小克對弈</title>
    <link rel="stylesheet" href="shared-styles.css">
    <style>
        :root {
            /* Game-specific color overrides */
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --shadow-button: 0 4px 15px rgba(102, 126, 234, 0.4);

            /* Go-specific board variables */
            --board-bg: #deb887;
            --board-lines: #d4a76a;
            --board-easy-start: #d4c5a9;
            --board-medium-start: var(--board-bg);
            --board-medium-end: #cd9b5e;

            /* Go stone variables */
            --stone-black-gradient: radial-gradient(circle at 30% 30%, #4a4a4a, #000000);
            --stone-white-gradient: radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0);
            --stone-white-border: #ccc;
            --stone-black-border-hc: #000000;
            --stone-white-border-hc: #333333;
            --shadow-capture-black: 0.0625rem 0.0625rem 0.125rem rgba(0,0,0,0.5);
            --shadow-capture-white: 0.0625rem 0.0625rem 0.125rem rgba(0,0,0,0.3);
        }

        /* Base styles now in shared-styles.css */

        /* Welcome screen styles now in shared-styles.css */

        /* Start button styles now in shared-styles.css */

        /* Game screen and header styles now in shared-styles.css */
        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }


        .game-title {
            font-size: clamp(1.25rem, 5vw, 1.75rem);
            font-weight: bold;
            color: var(--text-primary);
            margin: 0;
        }



        /* #board-container styles now in shared-styles.css */

        #board-container.easy-mode {
            background: linear-gradient(135deg, var(--board-easy-start) 0%, var(--board-bg) 100%);
        }

        #board-container.medium-mode {
            background: linear-gradient(135deg, var(--board-medium-start) 0%, var(--board-medium-end) 100%);
        }

        #board-container.hard-mode {
            background: linear-gradient(135deg, var(--board-bg) 0%, var(--board-medium-end) 100%);
        }

        #board {
            position: relative;
            width: 100%;
            height: 100%;
            background: var(--board-surface);
            background-image:
                repeating-linear-gradient(0deg, var(--board-lines) 0, var(--board-lines) 1px, transparent 1px, transparent 100%),
                repeating-linear-gradient(90deg, var(--board-lines) 0, var(--board-lines) 1px, transparent 1px, transparent 100%);
            border-radius: 0.3125rem;
            touch-action: none;
        }

        .intersection {
            position: absolute;
            width: 7.692307692%;
            height: 7.692307692%;
            cursor: pointer;
            z-index: 3;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: max(20px, 5cqw);
            min-height: max(20px, 5cqw);
        }

        @container (max-width: 300px) {
            .intersection {
                min-width: 18px;
                min-height: 18px;
            }
        }

        .stone {
            width: max(85%, 16px);
            height: max(85%, 16px);
            border-radius: 50%;
            position: relative;
            transition: opacity 0.3s, transform 0.2s;
            pointer-events: none;
        }

        .stone.black {
            background: var(--stone-black-gradient);
            box-shadow: var(--shadow-stone-black);
        }

        .stone.white {
            background: var(--stone-white-gradient);
            box-shadow: var(--shadow-stone-white);
            border: 1px solid var(--stone-white-border);
        }

        .stone.preview {
            opacity: 0.5;
        }

        .stone.last-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40%;
            height: 40%;
            border-radius: 50%;
            background: rgba(255, 0, 0, 0.8);
            animation: pulse 1s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            from { opacity: 0.8; }
            to { opacity: 0.4; }
        }

        .star-point {
            position: absolute;
            width: max(0.5rem, 2cqw);
            height: max(0.5rem, 2cqw);
            background: var(--modal-overlay);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
        }

        @container (max-width: 250px) {
            .star-point {
                width: 0.375rem;
                height: 0.375rem;
            }
        }


        #game-info {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: clamp(1.5rem, 5vw, 2rem);
            padding: 0.5rem;
        }

        .capture-item {
            font-size: clamp(0.875rem, 3.5vw, 1rem);
            font-weight: bold;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .capture-stone {
            width: clamp(0.875rem, 3.5vw, 1rem);
            height: clamp(0.875rem, 3.5vw, 1rem);
            border-radius: 50%;
            display: inline-block;
        }

        .capture-stone.black {
            background: var(--stone-black-gradient);
            box-shadow: var(--shadow-capture-black);
        }

        .capture-stone.white {
            background: var(--stone-white-gradient);
            box-shadow: var(--shadow-capture-white);
            border: 1px solid var(--stone-white-border);
        }

        .score-stone {
            display: inline-block;
            width: 0.875rem;
            height: 0.875rem;
            border-radius: 50%;
            vertical-align: middle;
            margin: 0 0.25rem;
        }

        .score-stone.black {
            background: radial-gradient(circle at 30% 30%, #4a4a4a, #000000);
            box-shadow: 0.0625rem 0.0625rem 0.125rem rgba(0,0,0,0.5);
        }

        .score-stone.white {
            background: radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0);
            box-shadow: 0.0625rem 0.0625rem 0.125rem rgba(0,0,0,0.3);
            border: 1px solid #ccc;
        }




        /* Clean Difficulty Selector with Button Group */
        .difficulty-group {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding-right: 0.375rem; /* Space for focus outline */
        }

        .diff-label {
            font-size: 0.875rem;
            color: #666;
            font-weight: 500;
            margin-right: 0.5rem;
        }

        .diff-button-group {
            display: flex;
            border-radius: 0.5rem;
            overflow: visible;
            padding: 0.125rem; /* Space for focus outline */
        }

        .diff-button {
            width: 2rem;
            height: 2rem;
            border: 1px solid #d0d0d0;
            background: white;
            font-weight: 600;
            font-size: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0;
            margin-left: -1px; /* Overlap borders */
            position: relative;
        }

        /* First and last button rounded corners */
        .diff-button:first-child {
            border-radius: 0.375rem 0 0 0.375rem;
            margin-left: 0;
        }

        .diff-button:last-child {
            border-radius: 0 0.375rem 0.375rem 0;
        }

        .diff-button:hover {
            background: #f8f8f8;
            border-color: #999;
            z-index: 1; /* Bring to front */
        }

        .diff-button.active {
            background: var(--text-primary);
            color: white;
            border-color: var(--text-primary);
            z-index: 2; /* Above hover */
        }

        /* Subtle color coding - only when active */
        .diff-button.active[data-difficulty="easy"] {
            background: var(--difficulty-easy);
            border-color: var(--difficulty-easy);
        }

        .diff-button.active[data-difficulty="medium"] {
            background: var(--difficulty-medium);
            border-color: var(--difficulty-medium);
        }

        .diff-button.active[data-difficulty="hard"] {
            background: var(--difficulty-hard);
            border-color: var(--difficulty-hard);
        }

        .diff-button:focus-visible {
            outline: none;
            box-shadow: 0 0 0 3px rgba(74, 74, 74, 0.25);
            z-index: 3;
        }

        /* Colored focus shadows for active buttons */
        .diff-button.active[data-difficulty="easy"]:focus-visible {
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.25);
        }

        .diff-button.active[data-difficulty="medium"]:focus-visible {
            box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.25);
        }

        .diff-button.active[data-difficulty="hard"]:focus-visible {
            box-shadow: 0 0 0 3px rgba(244, 67, 54, 0.25);
        }

        .diff-button:active {
            background: #e0e0e0;
        }

        .diff-button.active:active {
            background: #333;
        }

        /* Darker shades for active button press states */
        .diff-button.active[data-difficulty="easy"]:active {
            background: #388E3C; /* Darker green */
        }

        .diff-button.active[data-difficulty="medium"]:active {
            background: #F57C00; /* Darker orange */
        }

        .diff-button.active[data-difficulty="hard"]:active {
            background: #D32F2F; /* Darker red */
        }

        /* Grid Toggle Group - matches difficultyGroup design */
        .grid-toggle-group {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding-right: 0.375rem; /* Space for focus outline */
        }

        .grid-label {
            font-size: 0.875rem;
            color: #666;
            font-weight: 500;
            margin-right: 0.5rem;
        }

        .grid-toggle {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 22px;
            cursor: pointer;
        }

        .grid-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
        }

        .grid-toggle-slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            border-radius: 22px;
            transition: background-color 0.3s, box-shadow 0.2s;
        }

        .grid-toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.3s, box-shadow 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .grid-toggle input:checked + .grid-toggle-slider {
            background-color: #4CAF50;
        }

        .grid-toggle input:checked + .grid-toggle-slider:before {
            transform: translateX(18px);
        }

        .grid-toggle input:focus-visible + .grid-toggle-slider {
            outline: none;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.25);
        }

        .grid-toggle:hover .grid-toggle-slider:before {
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }


        #board.no-grid {
            background-image: none;
            background: var(--board-surface);
        }

        #board.no-grid .grid-line {
            display: none;
        }

        #board:not(.no-grid) .grid-line {
            display: block;
        }

        .grid-line {
            position: absolute;
            background: #d4a76a;
            pointer-events: none;
            z-index: 1;
            opacity: 0.5;
        }

        .grid-line.horizontal {
            width: 100%;
            height: 1px;
        }

        .grid-line.vertical {
            width: 1px;
            height: 100%;
        }

        #controls {
            display: flex;
            gap: clamp(0.5rem, 2vw, 0.75rem);
            padding: 0.25rem; /* Prevent focus outline clipping */
        }

        .control-button {
            flex: 1;
            background: var(--card-bg);
            border: none;
            border-radius: var(--border-radius);
            padding: 0.5rem 1.5rem;
            font-size: clamp(0.875rem, 3.5vw, 1rem);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            min-height: max(2rem, 44px);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .control-button:active {
            background: #f0f0f0;
            transform: scale(0.95);
        }

        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-button:focus-visible {
            outline: 2px solid var(--text-primary);
            outline-offset: 2px;
        }

        .control-button.pass {
            background: linear-gradient(135deg, #ffd89b 0%, #ffa751 100%);
            border: none;
            color: white;
            font-weight: bold;
        }

        /* Removed unused .control-button.resign styles */

        #end-game-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: clamp(1rem, 4vw, 2rem);
        }

        #end-game-modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--card-bg);
            border-radius: 1.25rem;
            padding: clamp(1.5rem, 5vw, 2rem);
            text-align: center;
            width: min(90vw, 400px);
            max-height: 90vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal-title {
            font-size: clamp(1.25rem, 5vw, 1.75rem);
            color: var(--text-primary);
            margin-bottom: 1.25rem;
            font-weight: bold;
        }

        .modal-score {
            font-size: clamp(1rem, 4vw, 1.375rem);
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .modal-message {
            font-size: clamp(0.875rem, 3.5vw, 1.125rem);
            color: var(--text-secondary);
            margin-bottom: 1.25rem;
            line-height: 1.4;
        }

        .score-details {
            background: #f8f8f8;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: left;
        }

        .score-detail {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            font-size: 16px;
        }

        .score-detail:last-child {
            border-bottom: none;
            font-weight: bold;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 2px solid #ccc;
        }

        .score-detail.black {
            color: #000;
        }

        .score-detail.white {
            color: #666;
        }

        .detail-label {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .detail-value {
            font-weight: 500;
        }

        .expand-button {
            background: #f0f0f0;
            border: none;
            border-radius: 10px;
            padding: 10px 20px;
            font-size: 16px;
            color: #666;
            cursor: pointer;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            width: 100%;
        }

        .expand-button:active {
            background: #e0e0e0;
        }

        .expand-button::after {
            content: '▼';
            font-size: 12px;
            transition: transform 0.3s;
        }

        .expand-button.expanded::after {
            transform: rotate(180deg);
        }

        .explanation-section {
            display: none;
            background: #fffbf0;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: left;
            border: 2px solid #f0e0c0;
        }

        .explanation-section.show {
            display: block;
        }

        .explanation-title {
            font-size: 20px;
            color: #4a4a4a;
            margin-bottom: 15px;
            font-weight: bold;
            text-align: center;
        }

        .explanation-content {
            font-size: 16px;
            color: #666;
            line-height: 1.8;
        }

        .explanation-content p {
            margin-bottom: 12px;
        }

        .explanation-content strong {
            color: #4a4a4a;
            font-weight: 600;
        }

        .territory-overlay {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            opacity: 0.4;
            z-index: 2;
            animation: fade-in 0.5s ease-in;
        }

        .territory-overlay.black-territory {
            background: radial-gradient(circle, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.5) 100%);
            box-shadow: 0 0 3px rgba(0,0,0,0.3);
        }

        .territory-overlay.white-territory {
            background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.6) 100%);
            border: 1px solid rgba(200,200,200,0.8);
            box-shadow: 0 0 3px rgba(255,255,255,0.5);
        }

        @keyframes fade-in {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 0.4; transform: scale(1); }
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
        }

        .modal-button {
            flex: 1;
            padding: 12px 20px;
            border-radius: 15px;
            border: none;
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .modal-button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
        }

        .modal-button.secondary {
            background: #f0f0f0;
            color: #666;
        }

        .modal-button:active {
            transform: scale(0.95);
        }


        /* Small screens - better single column layout */
        @media (max-width: 400px) {
            .header-row {
                gap: 0.5rem;
            }

            .difficulty-group {
                gap: 0.375rem;
                padding-right: 0.25rem;
            }

            .diff-label {
                font-size: 0.75rem;
                margin-right: 0.375rem;
            }

            .diff-button-group {
                padding: 0.0625rem;
            }

            .diff-button {
                width: 1.75rem;
                height: 1.75rem;
                font-size: 0.6875rem;
            }

            .grid-toggle-group {
                gap: 0.375rem;
                padding-right: 0.25rem;
            }

            .grid-label {
                font-size: 0.75rem;
                margin-right: 0.375rem;
            }

            .grid-toggle {
                width: 36px;
                height: 20px;
            }

            .grid-toggle-slider {
                border-radius: 20px;
            }

            .grid-toggle-slider:before {
                height: 14px;
                width: 14px;
            }

            .grid-toggle input:checked + .grid-toggle-slider:before {
                transform: translateX(16px);
            }

            /* Removed unused .icon-button styles */
        }

        /* Very small screens - compact layout */
        @media (max-width: 320px) {
            :root {
                --touch-target: max(2.5rem, 40px);
            }

            #game-container {
                padding: 0.5rem;
                gap: 0.5rem;
            }

            .header-row {
                gap: 0.25rem;
            }

            .game-title {
                font-size: 1.25rem;
            }

            .difficulty-group {
                gap: 0.25rem;
                padding-right: 0.1875rem;
            }

            .diff-label {
                margin-right: 0.25rem;
            }

            .grid-toggle-group {
                gap: 0.25rem;
                padding-right: 0.1875rem;
            }

            .grid-label {
                margin-right: 0.25rem;
            }

            .diff-button-group {
                padding: 0.0625rem;
            }

            .diff-button {
                width: 1.625rem;
                height: 1.625rem;
                font-size: 0.625rem;
            }
        }

        /* Large screens - optimize for desktop */
        @media (min-width: 768px) {

            #game-container {
                max-width: 500px;
            }

            .game-board-area {
                justify-content: center;
                align-items: center;
            }

            /* #board-container responsive styles now in shared-styles.css */
        }

        /* Accessibility - respect reduced motion */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            :root {
                --card-shadow: 0 4px 15px rgba(0,0,0,0.3);
                --text-primary: #000000;
                --text-secondary: #333333;
            }

            .stone.black {
                border: 2px solid var(--stone-black-border-hc);
            }

            .stone.white {
                border: 2px solid var(--stone-white-border-hc);
            }
        }

        @media (max-height: 540px) {
            :root {
                --game-content-width: 241px;
            }

            #board-container {
                min-width: 241px;
                min-height: 241px;
            }
        }           

        /* Compact mode for small height screens */
        @media (max-height: 650px) {
            #game-container {
                gap: 0.25rem;
            }

            .game-header, .game-footer {
                gap: 0.25rem;
            }

            #message-area {
                min-height: 2.5rem;
                padding: 0.5rem;
            }        

            .control-button {
                padding: 0.5rem 1rem;
                font-size: 0.875rem;
                min-height: 2.5rem;
            }

            #game-info {
                gap: 1rem;
                padding: 0.25rem;
            }

            .capture-item {
                font-size: 0.75rem;
            }

            #session-info {
                font-size: 0.75rem;
            }
        }
        
        @media (max-height: 661px) {
            .header-row {
                gap: 0.125rem;
            }

            .grid-toggle-group {
                gap: 0.125rem;
                flex-direction: column;
            }  

            .difficulty-group {
                gap: 0.125rem;
                flex-direction: column;
                padding-right: 0;
            }    
        }         
    </style>
</head>
<body>
    <div id="game-container">
        <div id="welcome-screen">
            <h1 class="welcome-title">歡迎來到圍棋世界</h1>
            <p class="welcome-message">您好！我是棋友小克！<br>讓我們一起享受下棋的樂趣吧！</p>
            <button class="start-button" onclick="startGame()">開始下棋</button>
        </div>

        <div id="game-screen">
            <div class="game-header">
                <div class="header-row">
                    <div class="grid-toggle-group">
                        <span class="grid-label">格線</span>
                        <label class="grid-toggle">
                            <input type="checkbox" checked onchange="toggleGrid(this.checked)"
                                   title="格線開關" aria-label="格線開關">
                            <span class="grid-toggle-slider"></span>
                        </label>
                    </div>

                    <h1 class="game-title">圍棋</h1>

                    <div class="difficulty-group">
                        <span class="diff-label">難度</span>
                        <div class="diff-button-group" role="group" aria-label="難度選擇">
                            <button class="diff-button active" data-difficulty="easy" onclick="changeDifficulty('easy')"
                                    title="簡單模式" aria-label="簡單難度">易</button>
                            <button class="diff-button" data-difficulty="medium" onclick="changeDifficulty('medium')"
                                    title="中等難度" aria-label="中等難度">中</button>
                            <button class="diff-button" data-difficulty="hard" onclick="changeDifficulty('hard')"
                                    title="困難模式" aria-label="困難難度">難</button>
                        </div>
                    </div>
                </div>

                <div id="message-area">
                    <div id="ai-message">您執黑子，請先下！觸碰任何交叉點落子。</div>
                </div>
            </div>

            <div class="game-board-area">
                <div id="board-container">
                    <div id="board"></div>
                </div>
            </div>

            <div class="game-footer">
                <div id="game-info">
                    <div class="capture-item">
                        <span>您：</span>
                        <span id="black-captures">0</span>
                        <span class="capture-stone black"></span>
                    </div>
                    <div class="capture-item">
                        <span>小克：</span>
                        <span id="white-captures">0</span>
                        <span class="capture-stone white"></span>
                    </div>
                </div>

                <div id="controls">
                    <button class="control-button" onclick="undoMove()">悔棋</button>
                    <button class="control-button pass" onclick="playerPass()">虛手</button>
                    <!-- Removed non-functional resign button -->
                </div>

                <div id="session-info">
                    第 <span id="session-games">0</span> 局 • 今日已玩 <span id="total-games">0</span> 局
                </div>
            </div>
        </div>

        <div id="end-game-modal">
            <div class="modal-content">
                <h2 class="modal-title">對局結束</h2>
                <div class="modal-score" id="final-score"></div>
                <p style="font-size: 14px; color: #999; margin: -10px 0 15px 0;">（棋盤上已標示領地）</p>

                <button class="expand-button" onclick="toggleExplanation()">
                    瞭解計分方式
                </button>

                <div class="explanation-section" id="explanation-section">
                    <div class="explanation-title">📚 圍棋計分說明</div>
                    <div class="explanation-content">
                        <p><strong>圍棋的目標：</strong><br>
                        佔領更多的地盤（空地）！不只是吃子喔。</p>

                        <p><strong>如何計算分數：</strong><br>
                        🏠 <strong>領地</strong>：您圍住的空地，每格算1分<br>
                        <span class="score-stone black"></span><strong>活棋</strong>：棋盤上您的棋子，每顆算1分<br>
                        🎯 <strong>提子</strong>：吃掉對方的棋子，每顆算1分</p>

                        <p><strong>貼目是什麼？</strong><br>
                        因為黑棋先下有優勢，所以白棋會得到6.5分補償，讓遊戲更公平。</p>

                        <p><strong>誰贏了？</strong><br>
                        總分高的一方獲勝！就這麼簡單。</p>
                    </div>
                </div>

                <div class="score-details">
                    <div class="score-detail black">
                        <span class="detail-label"><span class="score-stone black"></span>黑子計分</span>
                        <span class="detail-value"></span>
                    </div>
                    <div class="score-detail black" id="black-territory">
                        <span class="detail-label">　　領地</span>
                        <span class="detail-value">0 格</span>
                    </div>
                    <div class="score-detail black" id="black-stones">
                        <span class="detail-label">　　活棋</span>
                        <span class="detail-value">0 子</span>
                    </div>
                    <div class="score-detail black" id="black-captured">
                        <span class="detail-label">　　提子</span>
                        <span class="detail-value">0 個</span>
                    </div>
                    <div class="score-detail black">
                        <span class="detail-label"><strong>黑子總分</strong></span>
                        <span class="detail-value" id="black-total"><strong>0</strong></span>
                    </div>

                    <div style="margin: 15px 0;"></div>

                    <div class="score-detail white">
                        <span class="detail-label"><span class="score-stone white"></span>白子計分</span>
                        <span class="detail-value"></span>
                    </div>
                    <div class="score-detail white" id="white-territory">
                        <span class="detail-label">　　領地</span>
                        <span class="detail-value">0 格</span>
                    </div>
                    <div class="score-detail white" id="white-stones">
                        <span class="detail-label">　　活棋</span>
                        <span class="detail-value">0 子</span>
                    </div>
                    <div class="score-detail white" id="white-captured">
                        <span class="detail-label">　　提子</span>
                        <span class="detail-value">0 個</span>
                    </div>
                    <div class="score-detail white" id="white-komi">
                        <span class="detail-label">　　貼目</span>
                        <span class="detail-value">6.5 分</span>
                    </div>
                    <div class="score-detail white">
                        <span class="detail-label"><strong>白子總分</strong></span>
                        <span class="detail-value" id="white-total"><strong>0</strong></span>
                    </div>
                </div>

                <div class="modal-message" id="end-message"></div>
                <div class="modal-buttons">
                    <button class="modal-button primary" onclick="newGame()">再來一局</button>
                    <button class="modal-button secondary" onclick="takeBreak()">休息一下</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const BOARD_SIZE = 13;
        const EMPTY = 0;
        const BLACK = 1;
        const WHITE = 2;

        let board = [];
        let currentPlayer = BLACK;
        let gameStarted = false;
        let blackCaptures = 0;
        let whiteCaptures = 0;
        let koPosition = null;
        let lastMove = null;
        let moveHistory = [];
        let passCount = 0;
        let gameCount = 0;
        let winCount = 0;
        let lossCount = 0;
        let sessionGames = 0;
        let totalGamesToday = 0;
        let gridEnabled = true;
        let difficulty = 'easy'; // easy, medium, hard
        let difficultyAdjustment = true; // Auto-adjust difficulty based on performance

        // Update session information display
        function updateSessionInfo() {
            document.getElementById('session-games').textContent = sessionGames;
            document.getElementById('total-games').textContent = totalGamesToday;
        }

        const aiMessages = {
            opening: [
                "您的佈局很好！",
                "搶占角落，高明！",
                "我也要佔個好位置",
                "有趣的開局！",
                "這步棋很穩健"
            ],
            middle: [
                "激烈的戰鬥！",
                "這步棋很巧妙",
                "我得小心了",
                "局勢越來越有趣了",
                "您的進攻很猛烈！"
            ],
            capture: [
                "哎呀，我的棋子！",
                "漂亮的吃子！",
                "我要報仇！",
                "您抓住了好時機！",
                "真是精彩的手筋！"
            ],
            endgame: [
                "快分出勝負了",
                "這盤棋真精彩",
                "最後幾步了",
                "收官階段了",
                "勝負即將揭曉"
            ],
            encourage: [
                "不錯！繼續加油！",
                "您進步很多！",
                "這步棋有想法！",
                "您越下越好了！",
                "真是好棋！"
            ],
            difficulty: {
                easy: ["我喜歡和平的下棋", "讓我們各自建立地盤吧", "我不太喜歡打架"],
                medium: ["我會好好和您較量", "讓我們互相學習", "這局會很有意思"],
                hard: ["我要全力進攻！", "準備好激烈的戰鬥了嗎？", "每個子都要爭奪！"]
            },
            peaceful: [
                "我在角落建立基地",
                "這邊很安全",
                "我喜歡穩定的形狀",
                "慢慢擴展領地",
                "和平發展最好"
            ],
            aggressive: [
                "我要切斷您的棋！",
                "進攻開始了！",
                "這裡會很激烈",
                "不讓您安心做棋",
                "戰鬥！戰鬥！",
                "您的棋子危險了！",
                "我要入侵這裡！",
                "別想輕鬆建地盤！",
                "每一步都是戰鬥！",
                "看我怎麼攻破您的防線！"
            ],
            hardKill: [
                "叫吃！您的棋子要被吃了！",
                "哈哈！抓住了！",
                "這群棋子跑不掉了！",
                "看您怎麼救！",
                "您的大龍危險了！"
            ]
        };

        function initBoard() {
            board = [];
            for (let i = 0; i < BOARD_SIZE; i++) {
                board[i] = [];
                for (let j = 0; j < BOARD_SIZE; j++) {
                    board[i][j] = EMPTY;
                }
            }
            blackCaptures = 0;
            whiteCaptures = 0;
            koPosition = null;
            lastMove = null;
            moveHistory = [];
            passCount = 0;
            currentPlayer = BLACK;
            updateCaptures();
        }

        function createBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';

            // Apply grid class
            if (gridEnabled) {
                boardElement.classList.remove('no-grid');
            } else {
                boardElement.classList.add('no-grid');
            }

            // Always add grid lines (controlled by CSS opacity)
            for (let i = 0; i < BOARD_SIZE; i++) {
                // Horizontal lines
                const hLine = document.createElement('div');
                hLine.className = 'grid-line horizontal';
                hLine.style.top = `${(i / 12) * 100}%`;
                boardElement.appendChild(hLine);

                // Vertical lines
                const vLine = document.createElement('div');
                vLine.className = 'grid-line vertical';
                vLine.style.left = `${(i / 12) * 100}%`;
                boardElement.appendChild(vLine);
            }

            // Add star points
            const starPoints = [
                [3, 3], [3, 9], [6, 6], [9, 3], [9, 9]
            ];

            starPoints.forEach(([row, col]) => {
                const star = document.createElement('div');
                star.className = 'star-point';
                star.style.left = `${(col / 12) * 100}%`;
                star.style.top = `${(row / 12) * 100}%`;
                boardElement.appendChild(star);
            });

            // Create intersections
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    const intersection = document.createElement('div');
                    intersection.className = 'intersection';
                    intersection.style.left = `${(j / 12) * 100 - 3.845}%`;
                    intersection.style.top = `${(i / 12) * 100 - 3.845}%`;
                    intersection.dataset.row = i;
                    intersection.dataset.col = j;

                    intersection.addEventListener('click', handleIntersectionClick);
                    intersection.addEventListener('touchstart', handleTouch, {passive: true});
                    intersection.addEventListener('touchend', handleTouchEnd, {passive: false});

                    boardElement.appendChild(intersection);
                }
            }
        }

        function toggleGrid(enable) {
            // If no parameter provided, toggle current state
            if (enable === undefined) {
                gridEnabled = !gridEnabled;
            } else {
                gridEnabled = enable;
            }

            const boardElement = document.getElementById('board');
            const checkbox = document.querySelector('.grid-toggle input');

            // Update checkbox state (only if it's different to avoid infinite loop)
            if (checkbox && checkbox.checked !== gridEnabled) {
                checkbox.checked = gridEnabled;
            }

            // Update board grid visibility
            if (gridEnabled) {
                boardElement.classList.remove('no-grid');
            } else {
                boardElement.classList.add('no-grid');
            }
        }

        function updateBoardStyle() {
            const boardContainer = document.getElementById('board-container');
            if (!boardContainer) return; // Safety check

            // Remove all mode classes
            boardContainer.classList.remove('easy-mode', 'medium-mode', 'hard-mode');

            // Add the appropriate mode class
            if (difficulty === 'easy') {
                boardContainer.classList.add('easy-mode');
            } else if (difficulty === 'medium') {
                boardContainer.classList.add('medium-mode');
            } else {
                boardContainer.classList.add('hard-mode');
            }
        }

        function changeDifficulty(level) {
            difficulty = level;

            // Simple class toggle
            document.querySelectorAll('.diff-button').forEach((btn, index) => {
                btn.classList.toggle('active',
                    (level === 'easy' && index === 0) ||
                    (level === 'medium' && index === 1) ||
                    (level === 'hard' && index === 2)
                );
            });

            // Update board style
            updateBoardStyle();

            // Show personality message with extreme descriptions
            let personalityMessage = "";
            if (level === 'easy') {
                personalityMessage = "和平模式：我會躲在角落建設，絕對不會主動攻擊您";
            } else if (level === 'medium') {
                personalityMessage = "平衡模式：我會攻守兼備，看準時機進攻";
            } else if (level === 'hard') {
                personalityMessage = "戰鬥狂模式：我會瘋狂進攻！每一手都在找機會殺您的棋！";
            }

            showMessage(personalityMessage);

            // Turn off auto-adjustment when manually set
            difficultyAdjustment = false;
        }

        function setDifficulty(level) {
            difficulty = level;

            // Update button states
            document.querySelectorAll('.diff-button').forEach(btn => {
                btn.classList.remove('active');
                if ((level === 'easy' && btn.textContent === '簡單') ||
                    (level === 'medium' && btn.textContent === '中等') ||
                    (level === 'hard' && btn.textContent === '困難')) {
                    btn.classList.add('active');
                }
            });

            // Show personality-based message
            let personalityMessage = "";
            if (level === 'easy') {
                personalityMessage = "我會和平地建立自己的地盤，不太會攻擊您";
            } else if (level === 'medium') {
                personalityMessage = "我會平衡進攻和防守，尋找好機會";
            } else {
                personalityMessage = "我會積極進攻，每個地方都要戰鬥！";
            }

            showMessage(personalityMessage);

            // Turn off auto-adjustment when manually set
            difficultyAdjustment = false;
        }

        function adjustDifficultyAutomatically() {
            if (!difficultyAdjustment) return;

            // Auto-adjust based on win/loss ratio
            const totalGames = winCount + lossCount;
            if (totalGames >= 3) {
                const winRate = winCount / totalGames;

                if (winRate > 0.7 && difficulty !== 'hard') {
                    // Player winning too much, increase difficulty
                    if (difficulty === 'easy') {
                        setDifficultyLevel('medium');
                        setTimeout(() => showMessage("您很厲害！下一局我會更主動進攻"), 2000);
                    } else if (difficulty === 'medium') {
                        setDifficultyLevel('hard');
                        setTimeout(() => showMessage("您真是高手！下一局我要全力戰鬥了！"), 2000);
                    }
                    difficultyAdjustment = true; // Keep auto-adjustment on
                } else if (winRate < 0.3 && difficulty !== 'easy') {
                    // Player losing too much, decrease difficulty
                    if (difficulty === 'hard') {
                        setDifficultyLevel('medium');
                        setTimeout(() => showMessage("我太兇猛了，下一局溫和一點"), 2000);
                    } else if (difficulty === 'medium') {
                        setDifficultyLevel('easy');
                        setTimeout(() => showMessage("讓我們和平地下棋，各自發展"), 2000);
                    }
                    difficultyAdjustment = true; // Keep auto-adjustment on
                }
            }
        }

        function setDifficultyLevel(level) {
            difficulty = level;

            // Update button states
            document.querySelectorAll('.diff-button').forEach(btn => {
                btn.classList.remove('active');
                if ((level === 'easy' && btn.textContent === '簡單') ||
                    (level === 'medium' && btn.textContent === '中等') ||
                    (level === 'hard' && btn.textContent === '困難')) {
                    btn.classList.add('active');
                }
            });
        }

        let touchedIntersection = null;

        function handleTouch(e) {
            const intersection = e.currentTarget;
            const row = parseInt(intersection.dataset.row);
            const col = parseInt(intersection.dataset.col);

            if (currentPlayer === BLACK && board[row][col] === EMPTY) {
                touchedIntersection = intersection;
                showPreview(intersection, row, col);
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (touchedIntersection) {
                const row = parseInt(touchedIntersection.dataset.row);
                const col = parseInt(touchedIntersection.dataset.col);
                removePreview(touchedIntersection);
                placeStone(row, col);
                touchedIntersection = null;
            }
        }

        function showPreview(intersection, row, col) {
            if (board[row][col] === EMPTY && currentPlayer === BLACK) {
                const stone = document.createElement('div');
                stone.className = 'stone black preview';
                intersection.appendChild(stone);
            }
        }

        function removePreview(intersection) {
            const preview = intersection.querySelector('.preview');
            if (preview) {
                preview.remove();
            }
        }

        function handleIntersectionClick(e) {
            const intersection = e.currentTarget;
            const row = parseInt(intersection.dataset.row);
            const col = parseInt(intersection.dataset.col);

            if (currentPlayer === BLACK) {
                placeStone(row, col);
            }
        }

        function placeStone(row, col) {
            if (!gameStarted || currentPlayer !== BLACK) return;
            if (board[row][col] !== EMPTY) return;

            // Check ko rule
            if (koPosition && koPosition.row === row && koPosition.col === col) {
                showMessage("那裡不能下喔，試試其他地方！");
                return;
            }

            // Try placing the stone
            board[row][col] = BLACK;

            // Check for captures
            const captures = checkCaptures(row, col, WHITE);

            // Check for suicide
            if (!hasLiberties(row, col, BLACK) && captures.length === 0) {
                board[row][col] = EMPTY;
                showMessage("那裡不能下喔，試試其他地方！");
                return;
            }

            // Valid move
            passCount = 0;

            // Handle captures
            if (captures.length > 0) {
                captures.forEach(([r, c]) => {
                    board[r][c] = EMPTY;
                    blackCaptures++;
                });

                // Check for ko
                if (captures.length === 1 && !hasLiberties(row, col, BLACK)) {
                    koPosition = { row: captures[0][0], col: captures[0][1] };
                } else {
                    koPosition = null;
                }

                updateCaptures();
                showMessage(getRandomMessage('capture'));
            } else {
                koPosition = null;
                const moveCount = moveHistory.length;
                if (moveCount < 10) {
                    showMessage(getRandomMessage('opening'));
                } else if (moveCount < 50) {
                    showMessage(getRandomMessage('middle'));
                } else {
                    showMessage(getRandomMessage('endgame'));
                }
            }

            lastMove = { row, col };
            moveHistory.push({ row, col, player: BLACK });
            renderBoard();
            currentPlayer = WHITE;

            setTimeout(makeAIMove, 1000);
        }

        function hasLiberties(row, col, color) {
            const visited = new Set();
            return checkGroupLiberties(row, col, color, visited) > 0;
        }

        function checkGroupLiberties(row, col, color, visited) {
            if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) return 0;

            const key = `${row},${col}`;
            if (visited.has(key)) return 0;

            if (board[row][col] === EMPTY) return 1;
            if (board[row][col] !== color) return 0;

            visited.add(key);

            let liberties = 0;
            const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];

            for (const [dr, dc] of neighbors) {
                liberties += checkGroupLiberties(row + dr, col + dc, color, visited);
            }

            return liberties;
        }

        function checkCaptures(row, col, opponentColor) {
            const captures = [];
            const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];

            for (const [dr, dc] of neighbors) {
                const newRow = row + dr;
                const newCol = col + dc;

                if (newRow >= 0 && newRow < BOARD_SIZE &&
                    newCol >= 0 && newCol < BOARD_SIZE &&
                    board[newRow][newCol] === opponentColor) {

                    if (!hasLiberties(newRow, newCol, opponentColor)) {
                        const group = getGroup(newRow, newCol, opponentColor);
                        captures.push(...group);
                    }
                }
            }

            return captures;
        }

        function getGroup(row, col, color) {
            const group = [];
            const visited = new Set();
            const stack = [[row, col]];

            while (stack.length > 0) {
                const [r, c] = stack.pop();
                const key = `${r},${c}`;

                if (visited.has(key)) continue;
                visited.add(key);

                if (board[r][c] === color) {
                    group.push([r, c]);

                    const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
                    for (const [dr, dc] of neighbors) {
                        const newRow = r + dr;
                        const newCol = c + dc;
                        if (newRow >= 0 && newRow < BOARD_SIZE &&
                            newCol >= 0 && newCol < BOARD_SIZE) {
                            stack.push([newRow, newCol]);
                        }
                    }
                }
            }

            return group;
        }

        function evaluateMove(row, col, color) {
            // Advanced move evaluation for better AI
            let score = 0;

            // Check captures
            const captures = checkCaptures(row, col, color === WHITE ? BLACK : WHITE);
            score += captures.length * 50;

            // Count liberties after the move
            board[row][col] = color;
            const liberties = countGroupLiberties(row, col, color);
            board[row][col] = EMPTY;
            score += liberties * 5;

            // Distance from edges (center is often strategic in middle game)
            const distFromEdge = Math.min(row, col, BOARD_SIZE - 1 - row, BOARD_SIZE - 1 - col);

            // Opening strategy - corners and sides
            if (moveHistory.length < 15) {
                if ((row <= 3 || row >= 9) && (col <= 3 || col >= 9)) {
                    score += 25; // Corner area
                }
                if (row <= 1 || row >= 11 || col <= 1 || col >= 11) {
                    score += 15; // Edge area
                }
            } else {
                // Middle game - balance center and sides
                score += distFromEdge * 2;
            }

            // Connection to friendly stones
            const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
            let friendlyNeighbors = 0;
            let enemyNeighbors = 0;

            for (const [dr, dc] of neighbors) {
                const nr = row + dr;
                const nc = col + dc;
                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                    if (board[nr][nc] === color) friendlyNeighbors++;
                    else if (board[nr][nc] !== EMPTY) enemyNeighbors++;
                }
            }

            score += friendlyNeighbors * 8;

            // Check if move threatens enemy groups
            for (const [dr, dc] of neighbors) {
                const nr = row + dr;
                const nc = col + dc;
                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                    if (board[nr][nc] === (color === WHITE ? BLACK : WHITE)) {
                        // Temporarily place stone to check enemy liberties
                        board[row][col] = color;
                        const enemyLiberties = countGroupLiberties(nr, nc, board[nr][nc]);
                        board[row][col] = EMPTY;

                        if (enemyLiberties === 1) score += 40; // Atari!
                        else if (enemyLiberties === 2) score += 20; // Threatening
                    }
                }
            }

            return score;
        }

        function countGroupLiberties(row, col, color) {
            const visited = new Set();
            const liberties = new Set();

            function explore(r, c) {
                if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) return;

                const key = `${r},${c}`;
                if (visited.has(key)) return;

                if (board[r][c] === EMPTY) {
                    liberties.add(key);
                    return;
                }

                if (board[r][c] !== color) return;

                visited.add(key);

                const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
                for (const [dr, dc] of neighbors) {
                    explore(r + dr, c + dc);
                }
            }

            explore(row, col);
            return liberties.size;
        }

        function makeAIMove() {
            if (!gameStarted || currentPlayer !== WHITE) return;

            const validMoves = [];

            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === EMPTY) {
                        // Check if move is legal
                        board[i][j] = WHITE;
                        const captures = checkCaptures(i, j, BLACK);
                        const wouldBeSuicide = !hasLiberties(i, j, WHITE) && captures.length === 0;
                        const isKo = koPosition && koPosition.row === i && koPosition.col === j;

                        if (!wouldBeSuicide && !isKo) {
                            // Calculate score based on difficulty
                            let score = evaluateMove(i, j, WHITE);

                            // Difficulty-based adjustments
                            if (difficulty === 'easy') {
                                // Easy mode: Peaceful, avoid confrontation
                                // Prefer empty corners and building territory
                                const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
                                let hasEnemyNeighbor = false;
                                for (const [dr, dc] of neighbors) {
                                    const nr = i + dr;
                                    const nc = j + dc;
                                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                                        if (board[nr][nc] === BLACK) {
                                            hasEnemyNeighbor = true;
                                            break;
                                        }
                                    }
                                }

                                if (hasEnemyNeighbor) {
                                    score -= 30; // Avoid playing near opponent
                                }

                                // Strongly prefer corners and peaceful areas
                                if ((i <= 2 || i >= 10) && (j <= 2 || j >= 10)) {
                                    score += 40;
                                }

                                // Add more randomness
                                score += Math.random() * 20;

                            } else if (difficulty === 'medium') {
                                // Medium mode: Balanced play
                                // Standard evaluation with some randomness
                                score += Math.random() * 10;

                            } else if (difficulty === 'hard') {
                                // Hard mode: Aggressive, seeks fights
                                // Look for cutting and attacking moves
                                const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];

                                // Bonus for playing near opponent stones
                                for (const [dr, dc] of neighbors) {
                                    const nr = i + dr;
                                    const nc = j + dc;
                                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                                        if (board[nr][nc] === BLACK) {
                                            score += 25; // Seek contact

                                            // Check if we can reduce their liberties
                                            board[i][j] = WHITE;
                                            const enemyLibs = countGroupLiberties(nr, nc, BLACK);
                                            board[i][j] = EMPTY;

                                            if (enemyLibs <= 2) {
                                                score += 50; // Attack weak groups
                                            }
                                        }
                                    }
                                }

                                // Look for cutting points
                                let blackDiagonals = 0;
                                const diagonals = [[1,1], [1,-1], [-1,1], [-1,-1]];
                                for (const [dr, dc] of diagonals) {
                                    const nr = i + dr;
                                    const nc = j + dc;
                                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                                        if (board[nr][nc] === BLACK) blackDiagonals++;
                                    }
                                }
                                if (blackDiagonals >= 2) {
                                    score += 30; // Potential cutting point
                                }

                                // Less randomness for more consistent aggression
                                score += Math.random() * 5;
                            }

                            validMoves.push({ row: i, col: j, score, captures: captures.length });
                        }

                        board[i][j] = EMPTY;
                    }
                }
            }

            if (validMoves.length === 0) {
                aiPass();
                return;
            }

            // Sort by score
            validMoves.sort((a, b) => b.score - a.score);

            // Pick from top moves based on difficulty
            let move;
            if (difficulty === 'easy') {
                // More random, sometimes makes weak moves
                const topMoves = validMoves.slice(0, Math.min(10, validMoves.length));
                move = topMoves[Math.floor(Math.random() * topMoves.length)];
            } else if (difficulty === 'medium') {
                // Balanced selection from top moves
                const topMoves = validMoves.slice(0, Math.min(5, validMoves.length));
                move = topMoves[Math.floor(Math.random() * topMoves.length)];
            } else {
                // Hard mode: Usually picks best move
                if (Math.random() < 0.8) {
                    move = validMoves[0]; // Best move
                } else {
                    const topMoves = validMoves.slice(0, Math.min(3, validMoves.length));
                    move = topMoves[Math.floor(Math.random() * topMoves.length)];
                }
            }

            board[move.row][move.col] = WHITE;

            const captures = checkCaptures(move.row, move.col, BLACK);
            if (captures.length > 0) {
                captures.forEach(([r, c]) => {
                    board[r][c] = EMPTY;
                    whiteCaptures++;
                });

                if (captures.length === 1 && !hasLiberties(move.row, move.col, WHITE)) {
                    koPosition = { row: captures[0][0], col: captures[0][1] };
                } else {
                    koPosition = null;
                }

                updateCaptures();

                // Capture messages based on difficulty
                if (difficulty === 'hard' && captures.length > 1) {
                    showMessage(getRandomMessage('hardKill'));
                } else {
                    showMessage("我吃掉了您的棋子！");
                }
            } else {
                koPosition = null;

                // Context-aware messages based on difficulty and game phase
                if (difficulty === 'easy') {
                    if (moveHistory.length < 10) {
                        showMessage(getRandomMessage('peaceful'));
                    } else if (Math.random() < 0.3) {
                        showMessage(getRandomMessage('encourage'));
                    }
                } else if (difficulty === 'hard') {
                    // Check if we're threatening opponent stones
                    let threatening = false;
                    const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
                    for (const [dr, dc] of neighbors) {
                        const nr = move.row + dr;
                        const nc = move.col + dc;
                        if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE &&
                            board[nr][nc] === BLACK) {
                            const libs = countGroupLiberties(nr, nc, BLACK);
                            if (libs <= 2) {
                                threatening = true;
                                break;
                            }
                        }
                    }

                    if (threatening) {
                        showMessage(getRandomMessage('aggressive'));
                    } else if (moveHistory.length < 10) {
                        showMessage("我要控制這個區域！");
                    }
                } else {
                    // Medium difficulty - balanced messages
                    if (moveHistory.length < 10) {
                        showMessage("我也佔個好位置");
                    } else if (Math.random() < 0.2) {
                        showMessage(getRandomMessage('middle'));
                    }
                }
            }

            passCount = 0;
            lastMove = { row: move.row, col: move.col };
            moveHistory.push({ row: move.row, col: move.col, player: WHITE });
            renderBoard();
            currentPlayer = BLACK;
        }

        function renderBoard() {
            const intersections = document.querySelectorAll('.intersection');

            intersections.forEach(intersection => {
                const row = parseInt(intersection.dataset.row);
                const col = parseInt(intersection.dataset.col);

                // Clear existing stones
                intersection.innerHTML = '';

                if (board[row][col] !== EMPTY) {
                    const stone = document.createElement('div');
                    stone.className = `stone ${board[row][col] === BLACK ? 'black' : 'white'}`;

                    if (lastMove && lastMove.row === row && lastMove.col === col) {
                        stone.classList.add('last-move');
                    }

                    intersection.appendChild(stone);
                }
            });
        }

        function playerPass() {
            if (!gameStarted || currentPlayer !== BLACK) return;

            passCount++;
            showMessage("您虛手了，輪到我");
            currentPlayer = WHITE;

            if (passCount >= 2) {
                endGame();
            } else {
                setTimeout(makeAIMove, 1000);
            }
        }

        function aiPass() {
            passCount++;
            showMessage("我也虛手，對局結束！");
            currentPlayer = BLACK;

            if (passCount >= 2) {
                endGame();
            }
        }

        function undoMove() {
            if (moveHistory.length < 2 || currentPlayer !== BLACK) return;

            // Remove last two moves (AI and player)
            moveHistory.pop();
            moveHistory.pop();

            // Rebuild board from history
            initBoard();
            for (const move of moveHistory) {
                board[move.row][move.col] = move.player;
            }

            renderBoard();
            showMessage("好的，讓您重新考慮");
            currentPlayer = BLACK;
        }

        function calculateScore() {
            // Mark territories first
            const territoryMap = markTerritory();

            let blackTerritory = 0;
            let whiteTerritory = 0;
            let blackStoneCount = 0;
            let whiteStoneCount = 0;

            // Count stones and territories
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === BLACK) {
                        blackStoneCount++;
                    } else if (board[i][j] === WHITE) {
                        whiteStoneCount++;
                    } else if (board[i][j] === EMPTY) {
                        if (territoryMap[i][j] === BLACK) {
                            blackTerritory++;
                        } else if (territoryMap[i][j] === WHITE) {
                            whiteTerritory++;
                        }
                    }
                }
            }

            // Calculate final scores using Chinese rules
            const blackTotal = blackTerritory + blackStoneCount + blackCaptures;
            const whiteTotal = whiteTerritory + whiteStoneCount + whiteCaptures + 6.5;

            return {
                black: {
                    territory: blackTerritory,
                    stones: blackStoneCount,
                    captures: blackCaptures,
                    total: blackTotal
                },
                white: {
                    territory: whiteTerritory,
                    stones: whiteStoneCount,
                    captures: whiteCaptures,
                    komi: 6.5,
                    total: whiteTotal
                },
                territoryMap: territoryMap
            };
        }

        function markTerritory() {
            const territory = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));
            const visited = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(false));

            // Find all empty regions and determine their owner
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === EMPTY && !visited[i][j]) {
                        const region = [];
                        const owner = floodFillTerritory(i, j, visited, region);

                        // Mark the region with the owner's color
                        for (const [r, c] of region) {
                            territory[r][c] = owner;
                        }
                    }
                }
            }

            // Second pass: For small enclosed areas, use proximity-based assignment
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === EMPTY && territory[i][j] === EMPTY) {
                        // This empty point is disputed, assign based on influence
                        territory[i][j] = getInfluenceBasedOwner(i, j);
                    }
                }
            }

            return territory;
        }

        function floodFillTerritory(startRow, startCol, visited, region) {
            const stack = [[startRow, startCol]];
            const touchingColors = new Set();
            const boundaryStones = [];

            while (stack.length > 0) {
                const [row, col] = stack.pop();

                if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
                    continue;
                }

                if (visited[row][col]) continue;

                if (board[row][col] === EMPTY) {
                    visited[row][col] = true;
                    region.push([row, col]);

                    // Check all neighbors
                    const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
                    for (const [dr, dc] of neighbors) {
                        const newRow = row + dr;
                        const newCol = col + dc;

                        if (newRow >= 0 && newRow < BOARD_SIZE &&
                            newCol >= 0 && newCol < BOARD_SIZE) {

                            if (board[newRow][newCol] !== EMPTY) {
                                touchingColors.add(board[newRow][newCol]);
                                boundaryStones.push({color: board[newRow][newCol], row: newRow, col: newCol});
                            } else if (!visited[newRow][newCol]) {
                                stack.push([newRow, newCol]);
                            }
                        }
                    }
                }
            }

            // If the region touches only one color, that player owns it
            if (touchingColors.size === 1) {
                return touchingColors.values().next().value;
            }

            // If region is small and mostly surrounded by one color, assign to that color
            if (region.length <= 4) {
                let blackBoundary = 0;
                let whiteBoundary = 0;
                for (const stone of boundaryStones) {
                    if (stone.color === BLACK) blackBoundary++;
                    else whiteBoundary++;
                }

                // If 75% or more of boundary is one color, assign to that color
                const totalBoundary = blackBoundary + whiteBoundary;
                if (blackBoundary >= totalBoundary * 0.75) return BLACK;
                if (whiteBoundary >= totalBoundary * 0.75) return WHITE;
            }

            // Otherwise it's neutral/disputed
            return EMPTY;
        }

        function getInfluenceBasedOwner(row, col) {
            // Calculate influence based on nearby stones
            let blackInfluence = 0;
            let whiteInfluence = 0;

            // Check in a 3x3 area around the point
            for (let dr = -2; dr <= 2; dr++) {
                for (let dc = -2; dc <= 2; dc++) {
                    const r = row + dr;
                    const c = col + dc;
                    if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                        if (board[r][c] === BLACK) {
                            const distance = Math.abs(dr) + Math.abs(dc);
                            blackInfluence += (3 - Math.min(distance, 3));
                        } else if (board[r][c] === WHITE) {
                            const distance = Math.abs(dr) + Math.abs(dc);
                            whiteInfluence += (3 - Math.min(distance, 3));
                        }
                    }
                }
            }

            // Assign to the color with more influence
            if (blackInfluence > whiteInfluence + 2) return BLACK;
            if (whiteInfluence > blackInfluence + 2) return WHITE;

            // If influence is very close, check immediate neighbors only
            const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
            let blackNeighbors = 0;
            let whiteNeighbors = 0;

            for (const [dr, dc] of neighbors) {
                const nr = row + dr;
                const nc = col + dc;
                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                    if (board[nr][nc] === BLACK) blackNeighbors++;
                    else if (board[nr][nc] === WHITE) whiteNeighbors++;
                }
            }

            if (blackNeighbors > whiteNeighbors) return BLACK;
            if (whiteNeighbors > blackNeighbors) return WHITE;

            // Still can't decide - remain neutral
            return EMPTY;
        }

        function showTerritories(territoryMap) {
            // Remove old territory markers
            document.querySelectorAll('.territory-overlay').forEach(el => el.remove());

            const boardElement = document.getElementById('board');
            if (!boardElement) return;

            // Count territories for debugging
            let blackTerritoryCount = 0;
            let whiteTerritoryCount = 0;

            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === EMPTY && territoryMap[i][j] !== EMPTY) {
                        const overlay = document.createElement('div');
                        overlay.className = `territory-overlay ${territoryMap[i][j] === BLACK ? 'black-territory' : 'white-territory'}`;
                        overlay.style.position = 'absolute';
                        // Adjust positioning to center on intersection
                        overlay.style.left = `${(j / 12) * 100 - 3}%`;
                        overlay.style.top = `${(i / 12) * 100 - 3}%`;
                        overlay.style.width = '6%';
                        overlay.style.height = '6%';
                        boardElement.appendChild(overlay);

                        if (territoryMap[i][j] === BLACK) blackTerritoryCount++;
                        else if (territoryMap[i][j] === WHITE) whiteTerritoryCount++;
                    }
                }
            }

            console.log(`Territories marked - Black: ${blackTerritoryCount}, White: ${whiteTerritoryCount}`);
        }

        function clearTerritories() {
            document.querySelectorAll('.territory-overlay').forEach(el => el.remove());
        }

        function toggleExplanation() {
            const button = event.target;
            const section = document.getElementById('explanation-section');

            button.classList.toggle('expanded');
            section.classList.toggle('show');

            if (section.classList.contains('show')) {
                button.textContent = '收起說明';
            } else {
                button.textContent = '瞭解計分方式';
            }
        }

        function endGame() {
            gameStarted = false;
            const scoreData = calculateScore();
            const winner = scoreData.black.total > scoreData.white.total ? 'black' : 'white';
            const difference = Math.abs(scoreData.black.total - scoreData.white.total);

            // Show territories on the board
            showTerritories(scoreData.territoryMap);

            gameCount++;
            if (winner === 'black') {
                winCount++;
            } else {
                lossCount++;
            }

            // Update totalGamesToday and save to localStorage
            totalGamesToday++;
            localStorage.setItem('goGamesToday', totalGamesToday.toString());
            updateSessionInfo();

            // Auto-adjust difficulty if enabled
            adjustDifficultyAutomatically();

            const modal = document.getElementById('end-game-modal');
            const finalScore = document.getElementById('final-score');
            const endMessage = document.getElementById('end-message');

            // Update summary score
            finalScore.textContent = `黑: ${scoreData.black.total.toFixed(1)} 白: ${scoreData.white.total.toFixed(1)}`;

            // Update detailed breakdown
            document.querySelector('#black-territory .detail-value').textContent = `${scoreData.black.territory} 格`;
            document.querySelector('#black-stones .detail-value').textContent = `${scoreData.black.stones} 子`;
            document.querySelector('#black-captured .detail-value').textContent = `${scoreData.black.captures} 個`;
            document.getElementById('black-total').textContent = scoreData.black.total.toFixed(1);

            document.querySelector('#white-territory .detail-value').textContent = `${scoreData.white.territory} 格`;
            document.querySelector('#white-stones .detail-value').textContent = `${scoreData.white.stones} 子`;
            document.querySelector('#white-captured .detail-value').textContent = `${scoreData.white.captures} 個`;
            document.getElementById('white-total').textContent = scoreData.white.total.toFixed(1);

            // Personality-based end messages
            let personalityText = "";
            if (difficulty === 'easy') {
                personalityText = winner === 'black' ?
                    "您贏了！我的和平策略沒成功呢" :
                    "我靠著穩定的地盤贏了，但您下得很好！";
            } else if (difficulty === 'medium') {
                personalityText = winner === 'black' ?
                    "精彩的對局！您的策略更勝一籌！" :
                    "這次我贏了，但對局很精彩！";
            } else {
                personalityText = winner === 'black' ?
                    "您在激烈的戰鬥中獲勝了！真厲害！" :
                    "激烈的戰鬥後，我險勝了！";
            }

            if (winner === 'black') {
                endMessage.textContent = `${personalityText} 您贏了${difference.toFixed(1)}目！今日戰績: ${winCount}勝${lossCount}負`;
            } else {
                endMessage.textContent = `${personalityText} 我贏了${difference.toFixed(1)}目。今日戰績: ${winCount}勝${lossCount}負`;
            }

            modal.classList.add('active');
        }

        function newGame() {
            document.getElementById('end-game-modal').classList.remove('active');

            // Clear territory markings from previous game
            clearTerritories();

            initBoard();
            renderBoard();
            gameStarted = true;

            // Update session tracking
            sessionGames++;
            updateSessionInfo();

            // Reset explanation section
            const explanationSection = document.getElementById('explanation-section');
            const expandButton = document.querySelector('.expand-button');
            explanationSection.classList.remove('show');
            expandButton.classList.remove('expanded');
            expandButton.textContent = '瞭解計分方式';

            if (gameCount > 0 && gameCount % 5 === 0) {
                showMessage("您今天下了5局了，要不要休息一下？");
            } else {
                showMessage("新的一局開始！您執黑子先下。");
            }
        }

        function takeBreak() {
            document.getElementById('end-game-modal').classList.remove('active');
            clearTerritories();
            document.getElementById('game-screen').classList.remove('active');
            document.getElementById('welcome-screen').style.display = 'block';

            const welcomeMessage = document.querySelector('.welcome-message');
            welcomeMessage.innerHTML = `歡迎回來！<br>今日戰績: ${winCount}勝${lossCount}負<br>準備好再來一局了嗎？`;
        }

        function showMessage(message) {
            document.getElementById('ai-message').textContent = message;
        }

        function getRandomMessage(category) {
            const messages = aiMessages[category];
            return messages[Math.floor(Math.random() * messages.length)];
        }

        function updateCaptures() {
            document.getElementById('black-captures').textContent = blackCaptures;
            document.getElementById('white-captures').textContent = whiteCaptures;
        }

        function startGame() {
            document.getElementById('welcome-screen').style.display = 'none';
            document.getElementById('game-screen').classList.add('active');

            initBoard();
            createBoard();
            renderBoard();
            gameStarted = true;

            // Initialize session tracking
            totalGamesToday = parseInt(localStorage.getItem('goGamesToday') || '0');
            const today = new Date().toDateString();
            const lastPlayDate = localStorage.getItem('goLastPlayDate');

            if (lastPlayDate !== today) {
                totalGamesToday = 0;
                localStorage.setItem('goLastPlayDate', today);
            }

            updateSessionInfo();

            // Enable auto-adjustment for new session
            if (gameCount === 0) {
                difficultyAdjustment = true;
            }

            // Initialize settings UI
            const gridCheckbox = document.querySelector('.grid-toggle input');
            if (gridCheckbox) {
                gridCheckbox.checked = gridEnabled;
            }

            // Set initial difficulty buttons and hint
            document.querySelectorAll('.diff-button').forEach((btn, index) => {
                btn.classList.remove('active');
                if ((difficulty === 'easy' && index === 0) ||
                    (difficulty === 'medium' && index === 1) ||
                    (difficulty === 'hard' && index === 2)) {
                    btn.classList.add('active');
                }
            });

            // Set board style based on difficulty
            updateBoardStyle();

            if (gameCount === 0) {
                showMessage("您執黑子，請先下！觸碰任何交叉點落子。");
            } else {
                let personalityText = "";
                if (difficulty === 'easy') {
                    personalityText = "（和平模式）我會在自己的角落安靜建地盤";
                } else if (difficulty === 'medium') {
                    personalityText = "（平衡模式）我會認真和您對弈";
                } else {
                    personalityText = "（戰鬥狂模式）我要從第一手就開始進攻！";
                }
                showMessage(`第${gameCount + 1}局開始！${personalityText}`);
            }
        }

        // Prevent zooming on double tap
        document.addEventListener('touchend', function(e) {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        let lastTouchEnd = 0;
    </script>
</body>
</html>